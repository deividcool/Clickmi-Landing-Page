import {
  computed,
  getCurrentInstance,
  getCurrentScope,
  onScopeDispose,
  readonly,
  shallowRef
} from "./chunk-EYMNJ3H6.js";

// node_modules/@nanostores/vue/use-store/index.js
function registerStore(store) {
  let instance = getCurrentInstance();
  if (instance && instance.proxy) {
    let vm = instance.proxy;
    let cache = "_nanostores" in vm ? vm._nanostores : vm._nanostores = [];
    cache.push(store);
  }
}
function useStore(store) {
  let state = shallowRef();
  if (true) {
    if (typeof store === "function") {
      throw new Error(
        "Use useStore(Template(id)) or useSync() from @logux/client/vue for templates"
      );
    }
  }
  let unsubscribe = store.subscribe((value) => {
    state.value = value;
  });
  getCurrentScope() && onScopeDispose(unsubscribe);
  if (true) {
    registerStore(store);
    return readonly(state);
  }
  return state;
}

// node_modules/@nanostores/vue/map-stores/index.js
function mapStores(stores) {
  return Object.entries(stores).reduce((reduced, [storeName, store]) => {
    reduced[storeName] = useStore(store);
    return reduced;
  }, {});
}

// node_modules/@nanostores/vue/use-v-model/index.js
function useVModel(store, keys, opts = {}) {
  let prefix = opts.prefix || "Model";
  let state = useStore(store);
  if (Array.isArray(keys)) {
    return keys.reduce((reduced, key) => {
      reduced[`${key}${prefix}`] = computed({
        get: () => state.value[key],
        set: (value) => {
          store.setKey(key, value);
        }
      });
      return reduced;
    }, {});
  } else {
    let key = keys;
    return computed({
      get: () => key ? state.value[key] : state.value,
      set: (value) => {
        key ? store.setKey(key, value) : store.set(value);
      }
    });
  }
}
export {
  mapStores,
  registerStore,
  useStore,
  useVModel
};
//# sourceMappingURL=@nanostores_vue.js.map
