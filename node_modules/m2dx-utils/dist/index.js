// ../../internal/utils/src/ObjectLike.ts
function isObjectLike(object) {
  return !!object && typeof object === "object" && !Array.isArray(object) && !(object instanceof Date);
}

// ../../internal/utils/src/filters.ts
function isString(input) {
  return typeof input === "string";
}

// ../../internal/utils/src/print.ts
var colors = [
  "black",
  "blue",
  "boldGray",
  "boldGrey",
  "boldItalic",
  "boldWhite",
  "cyan",
  "gray",
  "green",
  "grey",
  "magenta",
  "onBlack",
  "onBlue",
  "onCyan",
  "onDarkBlue",
  "onGreen",
  "onMagenta",
  "onRed",
  "onWhite",
  "onYellow",
  "red",
  "steel",
  "white",
  "yellow"
];
var colorCodes = {
  black: 30,
  blue: 34,
  boldGray: 2,
  boldGrey: 2,
  boldItalic: 3,
  boldWhite: 1,
  cyan: 36,
  gray: 30,
  green: 32,
  grey: 30,
  magenta: 35,
  onBlack: 40,
  onBlue: 44,
  onCyan: 46,
  onDarkBlue: 100,
  onGreen: 42,
  onMagenta: 45,
  onRed: 41,
  onWhite: 47,
  onYellow: 43,
  red: 31,
  steel: 90,
  white: 37,
  yellow: 33
};
function _print(msg = "") {
  write(toString(msg));
}
function _println(msg = "") {
  write(toString(msg) + "\n");
}
function _withColor(msg, color) {
  return `\x1B[${colorCodes[color]}m${msg}\x1B[39;49m`;
}
var supported = /color|ansi|cygwin|linux/i.test(process.env.TERM ?? "");
colors.forEach((color) => {
  _print[color] = function(msg = "") {
    let s = toString(msg);
    if (supported) {
      s = _withColor(s, color);
    }
    write(s);
  };
  _println[color] = function(msg = "") {
    let s = toString(msg);
    if (supported) {
      s = _withColor(s, color);
    }
    write(s + "\n");
  };
  _withColor[color] = function(msg) {
    return _withColor(msg, color);
  };
});
function toString(msg) {
  return typeof msg === "string" ? msg : JSON.stringify(msg);
}
function write(msg) {
  process.stdout.write(msg);
}

// src/parseMdx.ts
import { remark } from "remark";
import remarkDirective from "remark-directive";
import remarkMdx from "remark-mdx";
function parseMdx(mdx) {
  return remark().use(remarkMdx).use(remarkDirective).parse(mdx);
}
function parseDirectives(mdx) {
  return remark().use(remarkDirective).parse(mdx);
}
function parseMd(mdx) {
  return remark().parse(mdx);
}
function deletePositions(root) {
  if (isObjectLike(root)) {
    Object.keys(root).forEach((k) => {
      const value = root[k];
      if (Array.isArray(value)) {
        value.forEach((item) => deletePositions(item));
      } else if (isObjectLike(value)) {
        if (k === "position") {
          delete root.position;
        } else {
          deletePositions(value);
        }
      }
    });
  }
}

// src/createJsxElement.ts
function createJsxElement(value) {
  const root = parseMdx(value);
  return root.children[0];
}

// src/parseEsm.ts
import { Parser } from "acorn";
function parseEsm(src) {
  return Parser.parse(src, {
    sourceType: "module",
    ecmaVersion: "latest"
  });
}

// src/createProgram.ts
function createProgram(value) {
  const estree = parseEsm(value);
  return {
    type: "mdxjsEsm",
    value,
    data: {
      estree
    }
  };
}

// src/embeddedHast.ts
function getHName(node) {
  return node.data?.hName;
}
function setHName(node, hName) {
  const data = node.data ?? (node.data = {});
  data.hName = hName;
}
function getHChildren(node) {
  const data = node.data ?? (node.data = {});
  return data.hChildren ?? (data.hChildren = []);
}
function getHProperties(node) {
  const data = node.data ?? (node.data = {});
  return data.hProperties ?? (data.hProperties = {});
}
function getHProperty(node, name) {
  const hProperties = node.data?.hProperties;
  return hProperties ? hProperties[name] : void 0;
}
function addHProperty(node, name, value) {
  const hProperties = getHProperties(node);
  hProperties[name] = value;
}
function addHClasses(node, ...classes) {
  if (!classes || classes.length === 0)
    return;
  const merged = /* @__PURE__ */ new Set();
  const existing = getHProperty(node, "class");
  if (typeof existing === "string") {
    existing.split(/\s/).forEach((s) => merged.add(s));
  }
  classes.filter(isString).forEach((c) => c?.split(/\s/).forEach((s) => !!s && s.trim().length > 0 && merged.add(s)));
  if (merged.size > 0) {
    getHProperties(node)["class"] = [...merged].join(" ");
  }
}

// src/estree.ts
function isImportDeclaration(node) {
  return !!node && node.type === "ImportDeclaration";
}
function isExportDefaultDeclaration(node) {
  return !!node && node.type === "ExportDefaultDeclaration";
}
function isObjectExpression(node) {
  return !!node && node.type === "ObjectExpression";
}
function isVariableDeclarator(node) {
  return !!node && node.type === "VariableDeclarator";
}
function isProperty(node) {
  return !!node && node.type === "Property";
}
function isIdentifier(node) {
  return !!node && node.type === "Identifier";
}

// src/visit.ts
function hasChildren(node) {
  return Object.keys(node).includes("children") && Array.isArray(node.children);
}
var CONTINUE = Symbol();
var EXIT = Symbol();
var SKIP = Symbol();
function visit(current, predicate, visitor) {
  if (!predicate && !visitor) {
    return;
  }
  if (!visitor) {
    visitor = predicate;
    predicate = void 0;
  }
  return visit_(current, void 0, -1, predicate, visitor, []);
}
function visit_(current, parent, index, predicate, visitor, ancestors) {
  if (!predicate || predicate(current)) {
    const action = visitor(current, parent, index, ancestors);
    switch (action) {
      case EXIT:
        return EXIT;
      case SKIP:
        return;
    }
  }
  if (hasChildren(current)) {
    const children = [...current.children];
    for (const child of children) {
      const index2 = current.children.indexOf(child);
      if (index2 >= 0) {
        const action = visit_(child, current, index2, predicate, visitor, [current, ...ancestors]);
        if (action === EXIT)
          return EXIT;
      }
    }
  }
}
async function visitAsync(current, predicate, visitor) {
  if (!predicate && !visitor) {
    return;
  }
  if (!visitor) {
    visitor = predicate;
    predicate = void 0;
  }
  return _visitAsync(current, void 0, -1, predicate, visitor);
}
async function _visitAsync(current, parent, index, predicate, visitor) {
  if (!predicate || predicate(current)) {
    const action = await visitor(current, parent, index);
    switch (action) {
      case EXIT:
        return EXIT;
      case SKIP:
        return;
    }
  }
  if (hasChildren(current)) {
    for (let index2 = 0; index2 < current.children.length; index2++) {
      const child = current.children[index2];
      if (await _visitAsync(child, current, index2, predicate, visitor) === EXIT) {
        return EXIT;
      }
    }
  }
}

// src/find.ts
function find(root, predicate) {
  let found;
  visit(root, predicate, function(node) {
    found = node;
    return EXIT;
  });
  return found;
}

// src/mdast.ts
function isRoot(node) {
  return !!node && node.type === "root";
}
function isParagraph(node) {
  return !!node && node.type === "paragraph";
}
function isHeading(node) {
  return !!node && node.type === "heading";
}
function isThematicBreak(node) {
  return !!node && node.type === "thematicBreak";
}
function isBlockquote(node) {
  return !!node && node.type === "blockquote";
}
function isList(node) {
  return !!node && node.type === "list";
}
function isListItem(node) {
  return !!node && node.type === "listItem";
}
function isTable(node) {
  return !!node && node.type === "table";
}
function isTableRow(node) {
  return !!node && node.type === "tableRow";
}
function isTableCell(node) {
  return !!node && node.type === "tableCell";
}
function isParent(node) {
  if (!node)
    return false;
  const type = node.type;
  switch (type) {
    case "break":
    case "code":
    case "footnoteReference":
    case "html":
    case "image":
    case "imageReference":
    case "inlineCode":
    case "text":
    case "yaml":
      return false;
    default:
      return true;
  }
}
function isPhrasingContent(node) {
  if (!node)
    return false;
  const type = node.type;
  switch (type) {
    case "break":
    case "delete":
    case "emphasis":
    case "footnote":
    case "footnoteReference":
    case "html":
    case "image":
    case "imageReference":
    case "inlineCode":
    case "strong":
    case "text":
      return true;
    default:
      return false;
  }
}
function isLiteral(node) {
  if (!node)
    return false;
  const type = node.type;
  switch (type) {
    case "code":
    case "definition":
    case "html":
    case "inlineCode":
    case "text":
    case "yaml":
      return true;
    default:
      return false;
  }
}
function isHTML(node) {
  return !!node && node.type === "html";
}
function isCode(node) {
  return !!node && node.type === "code";
}
function isYAML(node) {
  return !!node && node.type === "yaml";
}
function isAssociation(node) {
  if (!node)
    return false;
  const type = node.type;
  switch (type) {
    case "definition":
    case "footnoteDefinition":
    case "footnoteReference":
      return true;
    default:
      return false;
  }
}
function isResource(node) {
  if (!node)
    return false;
  const type = node.type;
  switch (type) {
    case "definition":
    case "link":
    case "image":
      return true;
    default:
      return false;
  }
}
function isDefinition(node) {
  return !!node && node.type === "definition";
}
function isFootnoteDefinition(node) {
  return !!node && node.type === "footnoteDefinition";
}
function isText(node) {
  return !!node && node.type === "text";
}
function isEmphasis(node) {
  return !!node && node.type === "emphasis";
}
function isStrong(node) {
  return !!node && node.type === "strong";
}
function isDelete(node) {
  return !!node && node.type === "delete";
}
function isInlineCode(node) {
  return !!node && node.type === "inlineCode";
}
function isBreak(node) {
  return !!node && node.type === "break";
}
function isLink(node) {
  return !!node && node.type === "link";
}
function isAlternative(node) {
  if (!node)
    return false;
  const type = node.type;
  switch (type) {
    case "image":
    case "imageReference":
      return true;
    default:
      return false;
  }
}
function isImage(node) {
  return !!node && node.type === "image";
}
function isReference(node) {
  if (!node)
    return false;
  const type = node.type;
  switch (type) {
    case "linkReference":
    case "imageReference":
      return true;
    default:
      return false;
  }
}
function isLinkReference(node) {
  return !!node && node.type === "linkReference";
}
function isImageReference(node) {
  return !!node && node.type === "imageReference";
}
function isFootnote(node) {
  return !!node && node.type === "footnote";
}
function isFootnoteReference(node) {
  return !!node && node.type === "footnoteReference";
}
function isMdxFlowExpression(node) {
  return !!node && node.type === "mdxFlowExpression";
}
function isMdxTextExpression(node) {
  return !!node && node.type === "mdxTextExpression";
}
function isMdxjsEsm(node) {
  return !!node && node.type === "mdxjsEsm";
}
function isMdxJsxAttributeValueExpression(node) {
  return !!node && node.type === "mdxJsxAttributeValueExpression";
}
function isMdxJsxAttribute(node) {
  return !!node && node.type === "mdxJsxAttribute";
}
function isMdxJsxExpressionAttribute(node) {
  return !!node && node.type === "mdxJsxExpressionAttribute";
}
function isMdxJsxFlowElement(node) {
  return !!node && node.type === "mdxJsxFlowElement";
}
function isJsxTag(tag) {
  return function(node) {
    return isMdxJsxFlowElement(node) && node.name === tag;
  };
}
function isMdxJsxTextElement(node) {
  return !!node && node.type === "mdxJsxTextElement";
}
function isDirective(node) {
  if (!node)
    return false;
  const type = node.type;
  switch (type) {
    case "containerDirective":
    case "leafDirective":
    case "textDirective":
      return true;
    default:
      return false;
  }
}
function isContainerDirective(node) {
  return !!node && node.type === "containerDirective";
}
function isLeafDirective(node) {
  return !!node && node.type === "leafDirective";
}
function isTextDirective(node) {
  return !!node && node.type === "textDirective";
}

// src/findAllImages.ts
function findAllImages(root) {
  const result = [];
  visit(root, isImage, (node, parent) => {
    result.push([node, parent]);
  });
  return result;
}

// src/findAllImportSpecifiers.ts
function findAllImportSpecifiers(root) {
  const result = [];
  visit(root, isMdxjsEsm, (node) => {
    const body = node.data?.estree?.body;
    if (body) {
      body.filter(isImportDeclaration).forEach((d) => {
        const source = d.source.value;
        d.specifiers.forEach((s) => {
          result.push({
            name: s.local.name,
            source,
            isDefault: s.type === "ImportDefaultSpecifier"
          });
        });
      });
    }
  });
  return result;
}

// src/findAllJsxElements.ts
function findAllJsxElements(root, withXHTML = false) {
  const result = [];
  visit(root, isMdxJsxElement, (node) => {
    if (withXHTML || isNotXHTML(node.name)) {
      result.push(node);
    }
  });
  return result;
}
function isMdxJsxElement(node) {
  return !!node && (node.type === "mdxJsxFlowElement" || node.type === "mdxJsxTextElement");
}
var XHTML_TAG = /^[a-z]+$/;
function isNotXHTML(name) {
  return !!name && !XHTML_TAG.test(name.charAt(0));
}

// src/rehype.ts
import { toHast } from "mdast-util-to-hast";
import { toHtml } from "hast-util-to-html";
function rehype(root) {
  const hast = toHast(root, { allowDangerousHtml: true });
  const html = toHtml(hast, { allowDangerousHtml: true });
  return html;
}

// src/toText.ts
function toText(root, sep = " ") {
  const buffer = [];
  visit(root, (node) => {
    if (isText(node) || isInlineCode(node)) {
      buffer.push(node.value);
    }
  });
  return buffer.map((s) => s.trim()).join(sep).trim();
}
export {
  CONTINUE,
  EXIT,
  SKIP,
  addHClasses,
  addHProperty,
  createJsxElement,
  createProgram,
  deletePositions,
  find,
  findAllImages,
  findAllImportSpecifiers,
  findAllJsxElements,
  getHChildren,
  getHName,
  getHProperties,
  getHProperty,
  isAlternative,
  isAssociation,
  isBlockquote,
  isBreak,
  isCode,
  isContainerDirective,
  isDefinition,
  isDelete,
  isDirective,
  isEmphasis,
  isExportDefaultDeclaration,
  isFootnote,
  isFootnoteDefinition,
  isFootnoteReference,
  isHTML,
  isHeading,
  isIdentifier,
  isImage,
  isImageReference,
  isImportDeclaration,
  isInlineCode,
  isJsxTag,
  isLeafDirective,
  isLink,
  isLinkReference,
  isList,
  isListItem,
  isLiteral,
  isMdxFlowExpression,
  isMdxJsxAttribute,
  isMdxJsxAttributeValueExpression,
  isMdxJsxElement,
  isMdxJsxExpressionAttribute,
  isMdxJsxFlowElement,
  isMdxJsxTextElement,
  isMdxTextExpression,
  isMdxjsEsm,
  isObjectExpression,
  isParagraph,
  isParent,
  isPhrasingContent,
  isProperty,
  isReference,
  isResource,
  isRoot,
  isStrong,
  isTable,
  isTableCell,
  isTableRow,
  isText,
  isTextDirective,
  isThematicBreak,
  isVariableDeclarator,
  isYAML,
  parseDirectives,
  parseEsm,
  parseMd,
  parseMdx,
  rehype,
  setHName,
  toText,
  visit,
  visitAsync
};
