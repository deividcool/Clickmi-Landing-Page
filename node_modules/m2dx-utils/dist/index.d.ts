import { MdxJsxFlowElement, MdxjsEsm, MdxFlowExpression, MdxTextExpression, MdxJsxAttributeValueExpression, MdxJsxAttribute, MdxJsxExpressionAttribute, MdxJsxTextElement } from 'mdast-util-mdx';
import { ElementContent, Properties } from 'hast';
import { Root, Paragraph, Heading, ThematicBreak, Blockquote, List, ListItem, Table, TableRow, TableCell, PhrasingContent, Literal, HTML, Code, YAML, Association, Resource, Definition, FootnoteDefinition, Text, Emphasis, Strong, Delete, InlineCode, Break, Link, Alternative, Image, Reference, LinkReference, ImageReference, Footnote, FootnoteReference, Content, Parent as Parent$1 } from 'mdast';
import { Node as Node$1, Parent } from 'unist';
import { ImportDeclaration, ExportDefaultDeclaration, ObjectExpression, VariableDeclarator, Property, Identifier, Program as Program$1 } from 'estree';

declare function createJsxElement(value: string): MdxJsxFlowElement;

declare function createProgram(value: string): MdxjsEsm;

type Node = Node$1 & {
    data?: Record<string, any>;
} & Record<string, any>;
interface Program extends MdxjsEsm {
}
declare function isRoot(node: unknown): node is Root;
declare function isParagraph(node: unknown): node is Paragraph;
declare function isHeading(node: unknown): node is Heading;
declare function isThematicBreak(node: unknown): node is ThematicBreak;
declare function isBlockquote(node: unknown): node is Blockquote;
declare function isList(node: unknown): node is List;
declare function isListItem(node: unknown): node is ListItem;
declare function isTable(node: unknown): node is Table;
declare function isTableRow(node: unknown): node is TableRow;
declare function isTableCell(node: unknown): node is TableCell;
declare function isParent(node: unknown): node is Parent;
declare function isPhrasingContent(node: unknown): node is PhrasingContent;
declare function isLiteral(node: unknown): node is Literal;
declare function isHTML(node: unknown): node is HTML;
declare function isCode(node: unknown): node is Code;
declare function isYAML(node: unknown): node is YAML;
declare function isAssociation(node: unknown): node is Association;
declare function isResource(node: unknown): node is Resource;
declare function isDefinition(node: unknown): node is Definition;
declare function isFootnoteDefinition(node: unknown): node is FootnoteDefinition;
declare function isText(node: unknown): node is Text;
declare function isEmphasis(node: unknown): node is Emphasis;
declare function isStrong(node: unknown): node is Strong;
declare function isDelete(node: unknown): node is Delete;
declare function isInlineCode(node: unknown): node is InlineCode;
declare function isBreak(node: unknown): node is Break;
declare function isLink(node: unknown): node is Link;
declare function isAlternative(node: unknown): node is Alternative;
declare function isImage(node: unknown): node is Image;
declare function isReference(node: unknown): node is Reference;
declare function isLinkReference(node: unknown): node is LinkReference;
declare function isImageReference(node: unknown): node is ImageReference;
declare function isFootnote(node: unknown): node is Footnote;
declare function isFootnoteReference(node: unknown): node is FootnoteReference;
declare function isMdxFlowExpression(node: unknown): node is MdxFlowExpression;
declare function isMdxTextExpression(node: unknown): node is MdxTextExpression;
declare function isMdxjsEsm(node: unknown): node is MdxjsEsm;
declare function isMdxJsxAttributeValueExpression(node: unknown): node is MdxJsxAttributeValueExpression;
declare function isMdxJsxAttribute(node: unknown): node is MdxJsxAttribute;
declare function isMdxJsxExpressionAttribute(node: unknown): node is MdxJsxExpressionAttribute;
declare function isMdxJsxFlowElement(node: unknown): node is MdxJsxFlowElement;
declare function isJsxTag(tag: string): (node: unknown) => node is MdxJsxFlowElement;
declare function isMdxJsxTextElement(node: unknown): node is MdxJsxTextElement;
interface Directive extends Parent {
    name: string;
    attributes: Record<string, string>;
    children: Content[];
}
declare function isDirective(node: unknown): node is Directive;
interface ContainerDirective extends Directive {
    type: 'containerDirective';
}
declare function isContainerDirective(node: unknown): node is ContainerDirective;
interface LeafDirective extends Directive {
    type: 'leafDirective';
}
declare function isLeafDirective(node: unknown): node is LeafDirective;
interface TextDirective extends Directive {
    type: 'textDirective';
}
declare function isTextDirective(node: unknown): node is TextDirective;

declare function getHName(node: Node): string | undefined;
declare function setHName(node: Node, hName: string): void;
declare function getHChildren(node: Node): ElementContent[];
declare function getHProperties(node: Node): Properties;
declare function getHProperty(node: Node, name: string): string | number | boolean | (string | number)[] | null | undefined;
declare function addHProperty(node: Node, name: string, value: boolean | number | string | null | undefined | Array<string | number>): void;
declare function addHClasses(node: Node, ...classes: string[]): void;

declare function isImportDeclaration(node: unknown): node is ImportDeclaration;
declare function isExportDefaultDeclaration(node: unknown): node is ExportDefaultDeclaration;
declare function isObjectExpression(node: unknown): node is ObjectExpression;
declare function isVariableDeclarator(node: unknown): node is VariableDeclarator;
declare function isProperty(node: unknown): node is Property;
declare function isIdentifier(node: unknown): node is Identifier;

interface WithChildren extends Node {
    children: Node[];
}
declare const CONTINUE: unique symbol;
declare const EXIT: unique symbol;
declare const SKIP: unique symbol;
type Action = typeof CONTINUE | typeof EXIT | typeof SKIP | undefined;
type Predicate<T extends Node = Node> = (node: Node) => node is T;
type Visitor<T = Node> = (
/**
 * Current node
 */
node: T, 
/**
 * Immediate parent node
 */
parent: WithChildren | undefined, 
/**
 * Index of this node in it's parent's children list
 */
index: number, 
/**
 * List of ancestors, starting with parent, i.e. ancestors[0] === parent
 */
ancestors: WithChildren[]) => Action | void;
declare function visit(current: Node, visitor: Visitor): Action | void;
declare function visit<T extends Node>(current: Node, predicate: Predicate<T>, visitor: Visitor<T>): Action | void;
type AsyncResult = Promise<Action | void>;
type AsyncVisitor<T = Node> = (node: T, parent: WithChildren | undefined, index: number) => AsyncResult;
declare function visitAsync(current: Node, visitor: AsyncVisitor): AsyncResult;
declare function visitAsync<T extends Node>(current: Node, predicate: Predicate<T>, visitor: AsyncVisitor<T>): AsyncResult;

declare function find<T extends Node>(root: Node, predicate: Predicate<T>): T | undefined;

type FoundImage = [Image, Parent$1];
declare function findAllImages(root: Root): FoundImage[];

interface ImportSpecifier {
    name: string;
    source: string;
    isDefault: boolean;
}
declare function findAllImportSpecifiers(root: Root): ImportSpecifier[];

type MdxJsxElement = MdxJsxFlowElement | MdxJsxTextElement;
declare function findAllJsxElements(root: Root, withXHTML?: boolean): MdxJsxElement[];
declare function isMdxJsxElement(node: unknown): node is MdxJsxElement;

declare function parseEsm(src: string): Program$1;

declare function parseMdx(mdx: string): Root;
declare function parseDirectives(mdx: string): Root;
declare function parseMd(mdx: string): Root;
declare function deletePositions(root: unknown): void;

declare function rehype(root: Root): string;

declare function toText(root: Node, sep?: string): string;

export { Action, CONTINUE, ContainerDirective, EXIT, FoundImage, ImportSpecifier, LeafDirective, MdxJsxElement, Node, Predicate, Program, SKIP, TextDirective, Visitor, addHClasses, addHProperty, createJsxElement, createProgram, deletePositions, find, findAllImages, findAllImportSpecifiers, findAllJsxElements, getHChildren, getHName, getHProperties, getHProperty, isAlternative, isAssociation, isBlockquote, isBreak, isCode, isContainerDirective, isDefinition, isDelete, isDirective, isEmphasis, isExportDefaultDeclaration, isFootnote, isFootnoteDefinition, isFootnoteReference, isHTML, isHeading, isIdentifier, isImage, isImageReference, isImportDeclaration, isInlineCode, isJsxTag, isLeafDirective, isLink, isLinkReference, isList, isListItem, isLiteral, isMdxFlowExpression, isMdxJsxAttribute, isMdxJsxAttributeValueExpression, isMdxJsxElement, isMdxJsxExpressionAttribute, isMdxJsxFlowElement, isMdxJsxTextElement, isMdxTextExpression, isMdxjsEsm, isObjectExpression, isParagraph, isParent, isPhrasingContent, isProperty, isReference, isResource, isRoot, isStrong, isTable, isTableCell, isTableRow, isText, isTextDirective, isThematicBreak, isVariableDeclarator, isYAML, parseDirectives, parseEsm, parseMd, parseMdx, rehype, setHName, toText, visit, visitAsync };
