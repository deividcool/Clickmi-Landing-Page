// ../../internal/utils/src/ObjectLike.ts
function isObjectLike(object) {
  return !!object && typeof object === "object" && !Array.isArray(object) && !(object instanceof Date);
}

// ../../internal/utils/src/deepMerge.ts
function _merge(a, b) {
  const result = { ...a };
  Object.keys(b).forEach((key) => {
    const targetValue = a[key];
    const sourceValue = b[key];
    if (isObjectLike(targetValue) && isObjectLike(sourceValue)) {
      result[key] = _merge(targetValue, sourceValue);
    } else {
      result[key] = sourceValue;
    }
  });
  return result;
}
function deepMerge(...objects) {
  if (!objects || objects.length < 2) {
    throw new Error("You must at least provide two objects to deepMerge");
  }
  objects.forEach((o, i) => {
    if (!isObjectLike(o)) {
      throw new Error(`objects[${i}] '${JSON.stringify(o)}' is not an object, but ${typeof o}`);
    }
  });
  const [object_0, ...sources] = objects;
  let target = object_0;
  for (const source of sources) {
    target = _merge(target, source);
  }
  return target;
}

// ../../internal/utils/src/fs/index.ts
import { constants } from "fs";
import { access } from "fs/promises";
import { dirname, join, normalize } from "path";
async function exists(name) {
  if (!name) {
    throw new Error("'name' must be a valid filename");
  }
  try {
    await access(name, constants.F_OK);
    return true;
  } catch {
    return false;
  }
}
async function findUpAll(name, dir, stop) {
  if (!name) {
    throw new Error("'name' must be a valid filename");
  }
  if (!dir) {
    throw new Error("'dir' must be a valid directory name");
  }
  if (!stop) {
    throw new Error("'stop' must be a valid directory name");
  }
  dir = normalize(dir);
  if (stop) {
    stop = normalize(stop);
    if (!dir.startsWith(stop)) {
      throw new Error("'dir' must be a subdirectory of 'stop'");
    }
  }
  return findUpAll_(name, dir, stop);
}
async function findUpAll_(name, dir, stop) {
  const up = dir !== stop ? await findUpAll_(name, dirname(dir), stop) : [];
  const file = join(dir, name);
  if (await exists(file)) {
    return [...up, file];
  } else {
    return up;
  }
}

// ../../internal/utils/src/path.ts
import { existsSync } from "fs";
import { isAbsolute, join as join2, relative } from "path";
function toLinux(file) {
  return file.replaceAll("\\", "/");
}
function normalizeRelative(src, base, newbase, isPath = false, checkExistence = false) {
  let newsrc = toLinux(src);
  if (isPath && !isAbsolute(src) || newsrc.startsWith("./") || newsrc.startsWith("../")) {
    newsrc = join2(base, newsrc);
    if (newbase) {
      newsrc = relative(newbase, newsrc);
    }
    if (!isPath && !newsrc.startsWith("/") && !newsrc.startsWith("./") && !newsrc.startsWith("../")) {
      newsrc = "./" + newsrc;
    }
    newsrc = toLinux(newsrc);
    if (newsrc !== src && checkExistence && !existsSync(newbase ? join2(newbase, newsrc) : newsrc)) {
      return src;
    }
    return newsrc;
  }
  return src;
}
function normalizeAll(src, base, newbase, checkExistence = false) {
  if (typeof src === "string") {
    return normalizeRelative(src, base, newbase, false, checkExistence);
  } else if (Array.isArray(src)) {
    let changed = false;
    const newsrc = [];
    for (const value of src) {
      const newvalue = normalizeAll(value, base, newbase, checkExistence);
      newsrc.push(newvalue);
      if (newvalue !== value) {
        changed = true;
      }
    }
    return changed ? newsrc : src;
  } else if (isObjectLike(src)) {
    let changed = false;
    const newsrc = {};
    for (const [key, value] of Object.entries(src)) {
      const newvalue = normalizeAll(value, base, newbase, checkExistence);
      newsrc[key] = newvalue;
      if (newvalue !== value) {
        changed = true;
      }
    }
    return changed ? newsrc : src;
  }
  return src;
}

// ../../internal/utils/src/print.ts
var colors = [
  "black",
  "blue",
  "boldGray",
  "boldGrey",
  "boldItalic",
  "boldWhite",
  "cyan",
  "gray",
  "green",
  "grey",
  "magenta",
  "onBlack",
  "onBlue",
  "onCyan",
  "onDarkBlue",
  "onGreen",
  "onMagenta",
  "onRed",
  "onWhite",
  "onYellow",
  "red",
  "steel",
  "white",
  "yellow"
];
var colorCodes = {
  black: 30,
  blue: 34,
  boldGray: 2,
  boldGrey: 2,
  boldItalic: 3,
  boldWhite: 1,
  cyan: 36,
  gray: 30,
  green: 32,
  grey: 30,
  magenta: 35,
  onBlack: 40,
  onBlue: 44,
  onCyan: 46,
  onDarkBlue: 100,
  onGreen: 42,
  onMagenta: 45,
  onRed: 41,
  onWhite: 47,
  onYellow: 43,
  red: 31,
  steel: 90,
  white: 37,
  yellow: 33
};
function _print(msg = "") {
  write(toString(msg));
}
function _println(msg = "") {
  write(toString(msg) + "\n");
}
function _withColor(msg, color) {
  return `\x1B[${colorCodes[color]}m${msg}\x1B[39;49m`;
}
var supported = /color|ansi|cygwin|linux/i.test(process.env.TERM ?? "");
colors.forEach((color) => {
  _print[color] = function(msg = "") {
    let s = toString(msg);
    if (supported) {
      s = _withColor(s, color);
    }
    write(s);
  };
  _println[color] = function(msg = "") {
    let s = toString(msg);
    if (supported) {
      s = _withColor(s, color);
    }
    write(s + "\n");
  };
  _withColor[color] = function(msg) {
    return _withColor(msg, color);
  };
});
function toString(msg) {
  return typeof msg === "string" ? msg : JSON.stringify(msg);
}
function write(msg) {
  process.stdout.write(msg);
}

// ../../internal/utils/src/shortHash.ts
function shortHash(data) {
  const str = typeof data === "string" ? data : JSON.stringify(data);
  const seed = 0;
  let h1 = 3735928559 ^ seed;
  let h2 = 1103547991 ^ seed;
  for (let i = 0, ch; i < str.length; i++) {
    ch = str.charCodeAt(i);
    h1 = Math.imul(h1 ^ ch, 2654435761);
    h2 = Math.imul(h2 ^ ch, 1597334677);
  }
  h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507) ^ Math.imul(h2 ^ h2 >>> 13, 3266489909);
  h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507) ^ Math.imul(h1 ^ h1 >>> 13, 3266489909);
  const h3 = 4294967296 * (2097151 & h2) + (h1 >>> 0);
  return "t" + h3.toString(32);
}

// ../../internal/utils/src/text/cases.ts
function capitalize(input) {
  return input ? input.charAt(0).toUpperCase() + input.slice(1) : input;
}
var INITIAL_LETTER = /(?:^\w|[A-Z]|\b\w)/g;
function toCamelCase(input) {
  return input.replace(INITIAL_LETTER, function(letter, index) {
    return index == 0 ? letter : letter.toUpperCase();
  }).replace(/[^A-Za-z0-9_]+/g, "");
}

// src/index.ts
import { readFile as readFile4 } from "fs/promises";
import grayMatter from "gray-matter";
import { join as join6 } from "path";

// src/autoImports/index.ts
import { createProgram } from "m2dx-utils";

// src/Exports/Exports.ts
import { EXIT, visit } from "estree-util-visit";
import { readFile } from "fs/promises";
import {
  isExportDefaultDeclaration,
  isIdentifier,
  isObjectExpression,
  isProperty,
  isVariableDeclarator,
  parseEsm
} from "m2dx-utils";
var Exports = class {
  constructor(files, nameFilter = () => true) {
    this.files = files;
    this.nameFilter = nameFilter;
  }
  /** File name to array of Export elements */
  exports = {};
  async find(name) {
    if (!name)
      return null;
    for (const file of this.files) {
      let exports = this.exports[file];
      if (!exports) {
        const src = await readFile(file, "utf8");
        exports = parseExports(src, this.nameFilter).map((p) => {
          return { ...p, file };
        });
        this.exports[file] = exports;
      }
      const found = exports.find((e) => e.identifiers.includes(name));
      if (found) {
        return found;
      }
    }
    return null;
  }
};
function parseExports(src, predicate) {
  const root = parseEsm(src);
  const defaultExport = findDefaultExport(root);
  return findDeclarators(root, predicate, defaultExport);
}
function findDefaultExport(root) {
  let name = void 0;
  visit(root, (n) => {
    if (isExportDefaultDeclaration(n)) {
      name = n.declaration.name;
      return EXIT;
    }
  });
  return name;
}
function findDeclarators(root, predicate, defaultExport) {
  const result = [];
  visit(root, (n, k, i, ancestors) => {
    if (isVariableDeclarator(n)) {
      const declaration = ancestors[ancestors.length - 1];
      const init = n.init;
      if (declaration.kind === "const" && isObjectExpression(init)) {
        const name = n.id.name;
        const isDefault = name === defaultExport;
        if (isDefault || ancestors[ancestors.length - 2].type === "ExportNamedDeclaration") {
          const identifiers = init.properties.filter(isProperty).map((p) => p.key).map((k2) => getName(k2)).filter(predicate);
          if (identifiers.length > 0) {
            result.push({
              name,
              identifiers,
              isDefault
            });
          }
        }
      }
    }
  });
  return result;
}
function getName(key) {
  return isIdentifier(key) ? key.name : key.value ?? `Unknown type for key: ${key.type}`;
}

// src/autoImports/findUnresolved.ts
import { findAllImportSpecifiers, findAllJsxElements } from "m2dx-utils";
function findUnresolved(root) {
  const imports = findAllImportSpecifiers(root).map((i) => i.name);
  const elements = findAllJsxElements(root);
  return elements.filter((n) => !imports.includes(n.name ?? ""));
}

// src/autoImports/index.ts
async function autoImports(root, files, failUnresolved = false) {
  const unresolved = findUnresolved(root);
  if (unresolved.length === 0)
    return;
  const exports = new Exports(files.reverse(), isJsxName);
  const imports = [];
  for (const u of unresolved) {
    const e = await exports.find(u.name);
    if (e) {
      const alias = capitalize(toCamelCase(`${e.name}__${shortHash(e.file)}`));
      u.name = `${alias}.${u.name}`;
      if (!imports.includes(alias)) {
        imports.push(alias);
        root.children.push(createProgram(toImport(e, alias)));
      }
    } else if (failUnresolved) {
      throw new Error(
        `JSX component <${u.name}> cannot be resolved, please import it explicitly in your MDX file or add an autoImport with astro-m2dx, see https://astro-m2dx.netlify.app/options/auto-imports how to do that`
      );
    }
  }
}
function toImport({ file, name, isDefault }, alias) {
  return isDefault ? `import ${alias} from '${toLinux(file)}';` : `import {${name} as ${alias}} from '${toLinux(file)}'`;
}
var CAPITAL_LETTER = /[A-Z]/;
function isJsxName(name) {
  return !!name && name.length > 0 && CAPITAL_LETTER.test(name.charAt(0));
}

// src/componentDirectives/index.ts
import { createJsxElement, createProgram as createProgram2, isDirective, visitAsync } from "m2dx-utils";
async function componentDirectives(root, files) {
  const exports = new Exports(files.reverse());
  const imports = [];
  await visitAsync(root, isDirective, async (directive, parent, index) => {
    if (parent) {
      const e = await exports.find(directive.name);
      if (e) {
        const alias = capitalize(toCamelCase(`${e.name}__${shortHash(e.file)}`));
        const component = createJsxElement(`<${alias}.${directive.name} />`);
        Object.keys(directive.attributes).forEach((key) => {
          component.attributes ??= [];
          component.attributes.push({
            type: "mdxJsxAttribute",
            name: key,
            value: directive.attributes[key]
          });
        });
        component.children = directive.children;
        parent.children[index] = component;
        if (!imports.includes(alias)) {
          imports.push(alias);
          root.children.push(createProgram2(toImport2(e, alias)));
        }
      }
    }
  });
}
function toImport2({ file, name, isDefault }, as) {
  return isDefault ? `import ${as} from '${toLinux(file)}';` : `import {${name} as ${as}} from '${toLinux(file)}'`;
}

// src/exportComponents/index.ts
import { createProgram as createProgram3 } from "m2dx-utils";

// src/exportComponents/findExportInMdx.ts
import { EXIT as esEXIT, visit as esVisit } from "estree-util-visit";
import { EXIT as EXIT2, isMdxjsEsm, isObjectExpression as isObjectExpression2, isVariableDeclarator as isVariableDeclarator2, visit as visit2 } from "m2dx-utils";
function findExportInMdx(root) {
  let found = void 0;
  visit2(root, isMdxjsEsm, (node) => {
    if (found = findExportInProgram(node.data.estree)) {
      return EXIT2;
    }
  });
  return found;
}
function findExportInProgram(program) {
  let found = void 0;
  esVisit(program, (n, key, index, ancestors) => {
    if (isVariableDeclarator2(n)) {
      const name = n.id.name;
      const declaration = ancestors[ancestors.length - 1];
      if (name === "components" && declaration.kind === "const" && isObjectExpression2(n.init)) {
        found = n;
        return esEXIT;
      }
    }
  });
  return found;
}

// src/exportComponents/index.ts
function exportComponents(root, files) {
  const imports = files.map((f, i) => `import { components as _ac${i} } from '${toLinux(f)}';`).join("\n");
  root.children.push(createProgram3(imports));
  const found = findExportInMdx(root);
  if (found) {
    const init = found.init;
    for (let i = 0; i < files.length; i++) {
      init.properties = [
        { type: "SpreadElement", argument: { type: "Identifier", name: `_ac${i}` } },
        ...init.properties
      ];
    }
  } else {
    const spread = files.map((_, i) => `..._ac${i}`);
    const src = `export const components = {${spread.join(",")}};`;
    root.children.push(createProgram3(src));
  }
}

// src/identifyImages/index.ts
import { getHProperties, isImage, visit as visit3 } from "m2dx-utils";
import { relative as relative2 } from "path";
function identifyImages(root, file, prefix = "img_") {
  const ids = [];
  visit3(root, isImage, (node) => {
    const props = getHProperties(node);
    if (!props.id) {
      let id = node.alt ?? ":" + node.url;
      while (ids.includes(id)) {
        id = id + "_";
      }
      ids.push(id);
      const data = {
        file: relative2(process.cwd(), file.path),
        id
      };
      props.id = `${prefix}${shortHash(data)}`;
    }
  });
}

// src/includeDirective/index.ts
import {
  addHClasses,
  createJsxElement as createJsxElement2,
  createProgram as createProgram4,
  isLeafDirective,
  setHName,
  visit as visit4
} from "m2dx-utils";
import { join as join3 } from "path";
function includeDirective(root, dir, directiveName = "include") {
  let count = 0;
  visit4(root, isLeafDirective, (directive, parent, index, ancestors) => {
    if (parent && directive.name === directiveName) {
      const name = `Include__${count++}`;
      let included = createJsxElement2(
        `<${name}.Content components={${name}.components ?? {}} />`
      );
      const ref = directive.children[0].value;
      const importElement = createProgram4(`import * as ${name} from '${toLinux(join3(dir, ref))}';`);
      const classes = directive.attributes["class"];
      if (classes) {
        setHName(directive, "div");
        addHClasses(directive, directive.attributes.class);
        directive.children = [included];
        included = directive;
      }
      if (Object.keys(directive.attributes).includes("unwrap") && ancestors.length > 1) {
        const target = ancestors[1];
        const position = target.children.indexOf(parent) + 1;
        target.children.splice(position, 0, included);
        target.children.push(importElement);
        parent.children.splice(index, 1);
      } else {
        parent.children[index] = included;
        parent.children.push(importElement);
      }
    }
  });
}

// src/mergeFrontmatter/index.ts
import { readFile as readFile2 } from "fs/promises";
import YAML from "js-yaml";
import { dirname as dirname2, join as join4, normalize as normalize2 } from "path";
async function mergeFrontmatter(name, dir, stop, resolvePaths) {
  if (!name) {
    throw new Error("'name' must be a valid filename");
  }
  if (!dir) {
    throw new Error("'dir' must be a valid directory name");
  }
  if (!stop) {
    throw new Error("'stop' must be a valid directory name");
  }
  dir = normalize2(dir);
  stop = normalize2(stop);
  if (!dir.startsWith(stop)) {
    throw new Error("dir must be a subdirectory of stop");
  }
  return _mergeFrontmatter(dir, name, dir, stop, void 0, resolvePaths);
}
async function _mergeFrontmatter(targetDir, name, dir, stop, previous, resolvePaths) {
  const file = join4(dir, name);
  if (await exists(file)) {
    const yaml = await readFile2(file, "utf8");
    let current = YAML.load(yaml);
    if (resolvePaths) {
      current = normalizeAll(current, dir, targetDir, true);
    }
    if (previous) {
      previous = deepMerge(current, previous);
    } else {
      previous = current;
    }
  }
  if (dir === stop) {
    return previous;
  }
  return await _mergeFrontmatter(targetDir, name, dirname2(dir), stop, previous, resolvePaths);
}

// src/normalizePaths/index.ts
import { isDirective as isDirective2, isMdxJsxFlowElement, visit as visit5 } from "m2dx-utils";
async function normalizePaths(root, base, { rebase, checkExistence, includeOnly, exclude } = {}) {
  const isIncluded = includeOnly && exclude ? (node) => (includeOnly.includes(node.type) || includeOnly.includes(tag(node))) && !exclude.includes(node.type) && !exclude.includes(tag(node)) : includeOnly ? (node) => includeOnly.includes(node.type) || includeOnly.includes(tag(node)) : exclude ? (node) => !exclude.includes(node.type) && !exclude.includes(tag(node)) : () => true;
  visit5(root, isIncluded, function(node) {
    const url = node.url;
    if (typeof url === "string" && !!url) {
      node.url = normalizeRelative(node.url, base, rebase, true, checkExistence);
    }
    if (isMdxJsxFlowElement(node)) {
      node.attributes.forEach((a) => {
        if (typeof a.value === "string") {
          a.value = normalizeRelative(a.value, base, rebase, false, checkExistence);
        }
      });
    } else if (isDirective2(node)) {
      for (const key of Object.keys(node.attributes)) {
        node.attributes[key] = normalizeRelative(
          node.attributes[key],
          base,
          rebase,
          false,
          checkExistence
        );
      }
    }
  });
}
function tag(node) {
  if (isMdxJsxFlowElement(node)) {
    return `<${node.name}>`;
  }
  return "__NO_TAG__";
}

// src/relativeImages/index.ts
import { readFile as readFile3 } from "fs/promises";
import {
  createJsxElement as createJsxElement3,
  createProgram as createProgram5,
  isIdentifier as isIdentifier2,
  isImage as isImage2,
  isMdxJsxAttribute,
  isMdxJsxFlowElement as isMdxJsxFlowElement2,
  isObjectExpression as isObjectExpression3,
  isProperty as isProperty2,
  parseEsm as parseEsm2,
  visit as visit6
} from "m2dx-utils";
import path, { isAbsolute as isAbsolute2, join as join5 } from "path";
async function relativeImages(root, baseDir, files) {
  const relativeImages2 = [];
  visit6(root, isImage2, (node, parent) => {
    if (!isAbsolute2(node.url)) {
      relativeImages2.push([node, parent]);
    }
  });
  let imageComponent = { name: "img" };
  if (relativeImages2.length > 0) {
    imageComponent = await findImageComponent(root, files) ?? imageComponent;
    if (imageComponent.requiredImport) {
      root.children.push(imageComponent.requiredImport);
    }
  }
  let imageCount = 0;
  for (const [image, parent] of relativeImages2) {
    const path2 = join5(baseDir, image.url);
    if (await exists(path2)) {
      const index = parent.children.indexOf(image);
      if (index < 0) {
        throw new Error(
          `relativeImages: image (${image.url} [${image.position?.start.line}:${image.position?.start.column}]) does not have a parent`
        );
      }
      const name = `relImg__${imageCount++}`;
      const src = `src={${name}}`;
      const alt = image.alt ? ` alt="${image.alt}"` : "";
      const title = image.title ? ` title="${image.title}"` : "";
      const attributes = hPropertiesToAttributes(image.data?.hProperties);
      parent.children[index] = createJsxElement3(
        `<${imageComponent.name} ${src}${alt}${title}${attributes} />`
      );
      const imageImport = createProgram5(`import ${name} from '${toLinux(path2)}';`);
      root.children.push(imageImport);
    }
  }
  const relativeJsxImages = findAllRelativeJsxImageReferences(root);
  for (const attribute of relativeJsxImages) {
    const path2 = join5(baseDir, attribute.value);
    if (await exists(path2)) {
      const name = `relImg__${imageCount++}`;
      attribute.value = toAttributeValueExpressionStatement(name);
      const imageImport = createProgram5(`import ${name} from '${toLinux(path2)}';`);
      root.children.push(imageImport);
    }
  }
}
async function findImageComponent(root, files) {
  let img = findImgProperty(findExportInMdx(root));
  if (img) {
    return { name: img };
  } else if (files && files.length > 0) {
    files = [...files].reverse();
    for (const file of files) {
      img = findImgProperty(await findExportInFile(file));
      if (img) {
        const alias = `_ic__${shortHash(file)}`;
        return {
          name: `${alias}.img`,
          requiredImport: createProgram5(
            `import { components as ${alias} } from '${toLinux(file)}';`
          )
        };
      }
    }
  }
  return void 0;
}
function findImgProperty(decl) {
  const init = decl?.init;
  if (isObjectExpression3(init)) {
    const imgProperty = init.properties.filter(isProperty2).find((p) => p.key?.name === "img");
    if (imgProperty && isIdentifier2(imgProperty.value)) {
      return imgProperty.value.name;
    }
  }
  return void 0;
}
async function findExportInFile(file) {
  const src = await readFile3(file, "utf8");
  const program = parseEsm2(src);
  return findExportInProgram(program);
}
function hPropertiesToAttributes(properties) {
  if (!isObjectLike(properties)) {
    return "";
  }
  return " " + Object.keys(properties).map((k) => `${k}="${properties[k]}"`).join(" ");
}
var imageExtensions = [".jpg", ".jpeg", ".png", ".svg", ".webp", ".gif", ".tiff", ".avif"];
function findAllRelativeJsxImageReferences(root) {
  const result = [];
  visit6(root, isMdxJsxFlowElement2, (node) => {
    for (const attribute of node.attributes.filter(isMdxJsxAttribute)) {
      const value = attribute.value;
      if (typeof value === "string" && (value.startsWith("./") || value.startsWith("../"))) {
        if (imageExtensions.includes(path.extname(value))) {
          result.push(attribute);
        }
      }
    }
  });
  return result;
}
function toAttributeValueExpressionStatement(value) {
  return {
    type: "mdxJsxAttributeValueExpression",
    value,
    data: {
      estree: {
        type: "Program",
        body: [
          {
            type: "ExpressionStatement",
            expression: {
              type: "Identifier",
              name: value
            }
          }
        ],
        sourceType: "module"
      }
    }
  };
}

// src/scanTitleAndAbstract/index.ts
import { CONTINUE, EXIT as EXIT3, isHeading, isRoot, SKIP, toText, visit as visit7 } from "m2dx-utils";
function scanTitleAndAbstract(root, scanTitle = true, scanAbstract = true) {
  let title = void 0;
  const abstract = [];
  if (scanTitle || scanAbstract) {
    visit7(root, (node) => {
      if (isRoot(node)) {
        return CONTINUE;
      } else if (scanTitle && !title && isHeading(node) && node.depth === 1) {
        title = toText(node);
        if (!scanAbstract) {
          return EXIT3;
        } else {
          abstract.length = 0;
          return SKIP;
        }
      } else if (scanAbstract) {
        if (isHeading(node)) {
          if (node.depth === 1) {
            abstract.length = 0;
            return SKIP;
          }
          return EXIT3;
        }
        abstract.push(toText(node));
        return SKIP;
      }
    });
  }
  return [title, abstract.length === 0 ? void 0 : abstract.join("\n\n").trim()];
}

// src/styleDirectives/index.ts
import {
  addHClasses as addHClasses2,
  isContainerDirective,
  isDirective as isDirective3,
  isLeafDirective as isLeafDirective2,
  isListItem,
  isText,
  isTextDirective,
  setHName as setHName2,
  visit as visit8
} from "m2dx-utils";
function styleDirectives(root, style = "style") {
  const listStyle = `list-${style}`;
  visit8(root, isDirective3, (directive, parent, index, ancestors) => {
    if (parent) {
      if (directive.name === style) {
        if (isContainerDirective(directive)) {
          addHClasses2(directive, directive.attributes.class);
        } else if (isTextDirective(directive)) {
          let node;
          if (directive.children.length > 0) {
            setHName2(directive, "span");
            addHClasses2(directive, directive.attributes.class);
          } else {
            if (index > 0 && (node = parent.children[index - 1]) && !isText(node) && node.position.end.column === directive.position.start.column) {
              addHClasses2(node, directive.attributes.class);
            } else if (ancestors.length > 1 && isListItem(ancestors[1])) {
              addHClasses2(ancestors[1], directive.attributes.class);
            } else {
              addHClasses2(parent, directive.attributes.class);
            }
            parent.children.splice(index, 1);
          }
        } else {
          if (directive.children.length > 0) {
            setHName2(directive, "div");
            addHClasses2(directive, directive.attributes.class);
          } else {
            addHClasses2(parent, directive.attributes.class);
            parent.children.splice(index, 1);
          }
        }
      } else if (directive.name === listStyle && isLeafDirective2(directive)) {
        const next = parent.children[index + 1];
        if (next?.type === "list") {
          addHClasses2(next, directive.attributes.class);
          parent.children.splice(index, 1);
        }
      }
    }
  });
}

// src/unwrapImages/index.ts
import { isImage as isImage3, isParagraph, isText as isText2, isTextDirective as isTextDirective2, visit as visit9 } from "m2dx-utils";
function unwrapImages(root) {
  visit9(root, (node, parent, index, ancestors) => {
    if (isImage3(node) && index === 0 && isParagraph(parent)) {
      if (parent.children.filter(notIsWhitespace).length === 1) {
        const parentIndex = ancestors[1].children.indexOf(parent);
        ancestors[1].children.splice(parentIndex, 1, ...parent.children);
      }
    }
  });
}
function notIsWhitespace(node) {
  const isWhitespace = !node || isText2(node) && !node.value?.trim() || isTextDirective2(node);
  return !isWhitespace;
}

// src/index.ts
var DEFAULT_AUTO_IMPORTS_NAME = "_autoimports.ts";
var DEFAULT_COMPONENT_DIRECTIVES_NAME = "_directives.ts";
var DEFAULT_EXPORT_COMPONENTS_NAME = "_components.ts";
var DEFAULT_FRONTMATTER_NAME = "_frontmatter.yaml";
var DEFAULT_IMAGE_ID_PREFIX = "img_";
var DEFAULT_INCLUDE_DIRECTIVE_NAME = "include";
var DEFAULT_MDAST_NAME = "mdast";
var DEFAULT_NORMALIZE_PATHS = {
  withFrontmatter: true,
  rebase: void 0,
  checkExistence: true,
  includeOnly: void 0,
  exclude: void 0
};
var DEFAULT_RAW_MDX_NAME = "rawmdx";
var DEFAULT_SCAN_ABSTRACT_NAME = "abstract";
var DEFAULT_SCAN_TITLE_NAME = "title";
var DEFAULT_STYLE_DIRECTIVES_NAME = "style";
var plugin = (options = {}) => {
  const {
    addOns = [],
    autoImportsFailUnresolved: optAutoImportsFailUnresolved = false,
    frontmatter: optFrontmatter = false,
    relativeImages: optRelativeImages = false,
    unwrapImages: optUnwrapImages = false
  } = options;
  let {
    autoImports: optAutoImports = false,
    componentDirectives: optComponentDirectives = false,
    exportComponents: optExportComponents = false,
    identifyImages: optIdentifyImages = false,
    includeDirective: optIncludeDirective = false,
    mdast: optMdast = false,
    normalizePaths: optNormalizePaths = false,
    rawmdx: optRawmdx = false,
    scanAbstract: optScanAbstract = false,
    scanTitle: optScanTitle = false,
    styleDirectives: optStyleDirectives = false
  } = options;
  return async function transformer(root, file) {
    const originalSource = await readFile4(file.path, "utf8");
    let { data: frontmatter } = grayMatter(originalSource);
    frontmatter = deepMerge(frontmatter, file.data.astro.frontmatter);
    if (optRawmdx) {
      if (typeof optRawmdx !== "string") {
        optRawmdx = DEFAULT_RAW_MDX_NAME;
      }
      frontmatter[optRawmdx] ??= file.value;
    }
    if (optMdast) {
      if (typeof optMdast !== "string") {
        optMdast = DEFAULT_MDAST_NAME;
      }
      frontmatter[optMdast] ??= root;
    }
    if (optScanTitle || optScanAbstract) {
      if (optScanTitle && typeof optScanTitle !== "string") {
        optScanTitle = DEFAULT_SCAN_TITLE_NAME;
      }
      if (optScanAbstract && typeof optScanAbstract !== "string") {
        optScanAbstract = DEFAULT_SCAN_ABSTRACT_NAME;
      }
      const [title, abstract] = scanTitleAndAbstract(
        root,
        !!optScanTitle && !frontmatter[optScanTitle],
        !!optScanAbstract && !frontmatter[optScanAbstract]
      );
      if (title && optScanTitle) {
        frontmatter[optScanTitle] = title;
      }
      if (abstract && optScanAbstract) {
        frontmatter[optScanAbstract] = abstract;
      }
    }
    const stop = join6(file.cwd, "src");
    const dir = file.dirname;
    if (dir && optFrontmatter) {
      let optFrontmatterName = DEFAULT_FRONTMATTER_NAME;
      let optFrontmatterResolve = false;
      if (typeof optFrontmatter === "string") {
        optFrontmatterName = optFrontmatter;
      } else if (typeof optFrontmatter === "object") {
        optFrontmatterName = optFrontmatter.name ?? DEFAULT_FRONTMATTER_NAME;
        optFrontmatterResolve = optFrontmatter.resolvePaths ?? false;
      }
      const merged = await mergeFrontmatter(optFrontmatterName, dir, stop, optFrontmatterResolve);
      if (merged) {
        frontmatter = deepMerge(merged, frontmatter);
      }
    }
    if (dir && optNormalizePaths) {
      if (typeof optNormalizePaths === "string") {
        optNormalizePaths = { ...DEFAULT_NORMALIZE_PATHS, rebase: optNormalizePaths };
      } else if (typeof optNormalizePaths !== "object") {
        optNormalizePaths = DEFAULT_NORMALIZE_PATHS;
      } else {
        optNormalizePaths = { ...DEFAULT_NORMALIZE_PATHS, ...optNormalizePaths };
      }
      if (optNormalizePaths.withFrontmatter) {
        const { rebase, checkExistence } = optNormalizePaths;
        frontmatter = normalizeAll(frontmatter, dir, rebase, checkExistence);
      }
      normalizePaths(root, dir, optNormalizePaths);
    }
    file.data.astro.frontmatter = frontmatter;
    let exportComponentFiles;
    if (dir && optExportComponents) {
      if (typeof optExportComponents !== "string") {
        optExportComponents = DEFAULT_EXPORT_COMPONENTS_NAME;
      }
      exportComponentFiles = await findUpAll(optExportComponents, dir, stop);
      if (exportComponentFiles.length > 0) {
        exportComponents(root, exportComponentFiles);
      }
    }
    if (dir && optAutoImports) {
      if (typeof optAutoImports !== "string") {
        optAutoImports = DEFAULT_AUTO_IMPORTS_NAME;
      }
      const files = await findUpAll(optAutoImports, dir, stop);
      if (files.length > 0) {
        await autoImports(root, files, optAutoImportsFailUnresolved);
      }
    }
    if (optStyleDirectives) {
      if (typeof optStyleDirectives !== "string") {
        optStyleDirectives = DEFAULT_STYLE_DIRECTIVES_NAME;
      }
      styleDirectives(root, optStyleDirectives);
    }
    if (dir && optIncludeDirective) {
      if (typeof optIncludeDirective !== "string") {
        optIncludeDirective = DEFAULT_INCLUDE_DIRECTIVE_NAME;
      }
      includeDirective(root, dir, optIncludeDirective);
    }
    if (dir && optComponentDirectives) {
      if (typeof optComponentDirectives !== "string") {
        optComponentDirectives = DEFAULT_COMPONENT_DIRECTIVES_NAME;
      }
      const files = await findUpAll(optComponentDirectives, dir, stop);
      if (files.length > 0) {
        await componentDirectives(root, files);
      }
    }
    if (optUnwrapImages) {
      unwrapImages(root);
    }
    if (optIdentifyImages) {
      if (typeof optIdentifyImages === "boolean") {
        optIdentifyImages = DEFAULT_IMAGE_ID_PREFIX;
      }
      identifyImages(root, file, optIdentifyImages);
    }
    if (dir && optRelativeImages) {
      await relativeImages(root, dir, exportComponentFiles);
    }
    for (const addOn of addOns) {
      root = await addOn(root, file) ?? root;
    }
  };
};
var src_default = plugin;
export {
  src_default as default,
  plugin
};
