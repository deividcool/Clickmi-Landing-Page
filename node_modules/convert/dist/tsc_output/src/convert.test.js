import { stddev } from '@jonahsnider/util';
import { conversions } from 'bundled-conversions';
import { prod, dev } from '../test/convert';
import { assertConversions } from '../test/assert-conversion';
import { testWithBuilds } from '../test/with-builds';
const invalidUnit = 'not a valid unit';
/**
 * Manually defining this value is required instead of using `Indexes.Conversion.Family`.
 * This is because either Jest's custom module resolver, their Babel setup, or a mix of both doesn't properly handle the `const enum`s.
 * Instead of magically using the TypeScript source to get the enum values it uses the emitted code, which is undefined.
 *
 * The long-term solution to this is to simply stop using `const enum`s when exporting across package boundaries.
 * Unfortunately, Terser doesn't constant-fold the emitted 2-way lookup table that TypeScript emits for `enum` expressions.
 * A feature request for this has been opened on the Terser repository: https://github.com/terser/terser/issues/1064.
 */
const INDEXES_CONVERSION_FAMILY = 0;
describe('errors', () => {
    describe('production', () => {
        test('quantity type', () => {
            expect(() => prod.convert('123', 'meters')).toThrow(new TypeError(''));
        });
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        expect(() => prod.convert(123, invalidUnit)).toThrow(new RangeError(''));
        expect(() => prod
            .convert(123, 'ms')
            // @ts-expect-error Invalid unit
            .to(invalidUnit)).toThrow(TypeError);
        expect(() => prod
            .convert(1000, 'ms')
            // @ts-expect-error Invalid unit
            .to('meters')).toThrow(new RangeError(''));
        expect(() => prod.convert(1000n, 'ms').to('seconds')).toThrow(new RangeError('The number 0.001 cannot be converted to a BigInt because it is not an integer'));
        test('invalid best unit kind', () => {
            expect(() => prod.convert(123, 'in').to('best', 
            // @ts-expect-error Invalid best kind
            'invalid')).toThrow(new RangeError(''));
        });
    });
    describe('development', () => {
        test.each([
            // Quantity type
            { fn: () => dev.convert('123', 'meters'), error: TypeError },
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            { fn: () => dev.convert(123, invalidUnit), error: RangeError },
            {
                fn: () => dev
                    .convert(1000, 'ms')
                    // @ts-expect-error Invalid unit
                    .to(invalidUnit),
                error: RangeError,
            },
            {
                fn: () => dev
                    .convert(1000, 'ms')
                    // @ts-expect-error Invalid unit
                    .to('meters'),
                error: RangeError,
            },
            // Invalid best unit kind
            {
                fn: () => dev.convert(123, 'in').to('best', 
                // @ts-expect-error Invalid best kind
                'invalid'),
                error: RangeError,
            },
        ])('%p', ({ fn, error }) => {
            expect(fn).toThrow(error);
            expect(fn).toThrow(/.+/);
        });
        expect(() => dev
            .convert(123, 'ms')
            // @ts-expect-error Invalid unit
            .to('m')).toThrow(new RangeError('No conversion could be found from ms to m. Also, are you trying to convert quantities of time? Because "m" is treated as meters, not minutes. You probably want to use the "min" unit instead.'));
        expect(() => dev.convert(1000n, 'ms').to('seconds')).toThrow(new RangeError('Conversion for ms to seconds cannot be calculated as a BigInt because the conversion ratio is not an integer'));
    });
});
assertConversions([
    { from: [1, 'second'], to: [1, 'second'] },
    { from: [2n, 'hours'], to: [120n, 'minute'] },
]);
describe('roundtrip conversion', () => {
    describe.each(['m2', 'b', 'B', 'N', 'pdl', 'm', 'g', 'Pa', 'K', 's', 'm3'])('%p', baseUnit => {
        const desiredFamilyId = conversions[baseUnit][INDEXES_CONVERSION_FAMILY];
        test.each(Object.entries(conversions))(`${baseUnit} <-> $0`, (unit, data) => {
            if (!data) {
                return;
            }
            const familyId = data[INDEXES_CONVERSION_FAMILY];
            if (familyId !== desiredFamilyId) {
                return;
            }
            const value = 123;
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            const aToB = prod.convert(value, baseUnit).to(unit);
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            const bToA = prod.convert(aToB, unit).to(baseUnit);
            const difference = stddev([value, bToA]);
            if (difference !== 0) {
                // Not sure exactly why this value keeps showing up
                expect(difference).toBeCloseTo(0, 13);
            }
        });
    });
});
describe('precision loss from converting to best', () => {
    assertConversions([{ from: [1.5, 'days'], to: [1.5, 'd'] }]);
    testWithBuilds(mod => {
        const result = mod.convert(1.5, 'days').to('best');
        expect(result.unit).toBe('d');
        // Note: this used to not return 1.5, but after changing the smallest best unit from ns to fs it fixed itself
        // This is because of arithmetic precision limitations for 64-bit floats, which are used to represent the ratio used for seconds (3.1536e+22)
        expect(result.quantity).toBe(1.5);
        expect(result.toString()).toBe('1.5d');
        expect(result.quantity).toBe(1.5);
        expect(result.toString()).toBe(`${1.5}d`);
    });
});
describe('converting to best with rounding', () => {
    describe('works when removing decimal places', () => {
        testWithBuilds(mod => {
            expect(mod.convert(123_456, 'm').to('best').toString(2)).toBe('123.46km');
            expect(mod.convert(123_456, 'm').to('best').toString(0)).toBe('123km');
            expect(mod.convert(1000, 'micrometer').to('best').toString(1)).toBe('1.0mm');
            expect(mod.convert(1000, 'micrometer').to('best').toString(0)).toBe('1mm');
        });
    });
    describe('works when adding decimal places', () => {
        testWithBuilds(mod => {
            expect(mod.convert(1000, 'm').to('best').toString(4)).toBe('1.0000km');
            expect(mod.convert(1000, 'm').to('best').toString(0)).toBe('1km');
            expect(mod.convert(1000, 'micrometer').to('best').toString(4)).toBe('1.0000mm');
            expect(mod.convert(1000, 'micrometer').to('best').toString(0)).toBe('1mm');
        });
    });
    describe('does nothing when omitted', () => {
        testWithBuilds(mod => {
            expect(mod.convert(123_456, 'm').to('best').toString()).toBe('123.45599999999999km');
            expect(mod.convert(123_456, 'm').to('best').toString(undefined)).toBe('123.45599999999999km');
            expect(mod.convert(1000, 'micrometer').to('best').toString()).toBe('1mm');
            expect(mod.convert(1000, 'micrometer').to('best').toString(undefined)).toBe('1mm');
        });
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udmVydC50ZXN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbnZlcnQudGVzdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUMsTUFBTSxFQUFDLE1BQU0sbUJBQW1CLENBQUM7QUFDekMsT0FBTyxFQUFDLFdBQVcsRUFBQyxNQUFNLHFCQUFxQixDQUFDO0FBRWhELE9BQU8sRUFBQyxJQUFJLEVBQUUsR0FBRyxFQUFDLE1BQU0saUJBQWlCLENBQUM7QUFDMUMsT0FBTyxFQUFDLGlCQUFpQixFQUFDLE1BQU0sMkJBQTJCLENBQUM7QUFDNUQsT0FBTyxFQUFDLGNBQWMsRUFBQyxNQUFNLHFCQUFxQixDQUFDO0FBR25ELE1BQU0sV0FBVyxHQUFHLGtCQUFrQixDQUFDO0FBRXZDOzs7Ozs7OztHQVFHO0FBQ0gsTUFBTSx5QkFBeUIsR0FBOEIsQ0FBQyxDQUFDO0FBRS9ELFFBQVEsQ0FBQyxRQUFRLEVBQUUsR0FBRyxFQUFFO0lBQ3ZCLFFBQVEsQ0FBQyxZQUFZLEVBQUUsR0FBRyxFQUFFO1FBQzNCLElBQUksQ0FBQyxlQUFlLEVBQUUsR0FBRyxFQUFFO1lBQzFCLE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQVksRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLFNBQVMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQy9FLENBQUMsQ0FBQyxDQUFDO1FBRUgsaUVBQWlFO1FBQ2pFLE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxXQUFrQixDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxVQUFVLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUVoRixNQUFNLENBQUMsR0FBRyxFQUFFLENBQ1gsSUFBSTthQUNGLE9BQU8sQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDO1lBQ25C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TUFBTSxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsc0JBQXNCLENBQUMsQ0FBQztZQUNyRixNQUFNLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO1lBQzlGLE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxZQUFZLENBQUMsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDMUUsTUFBTSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLFlBQVksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDcEYsQ0FBQyxDQUFDLENBQUM7SUFDSixDQUFDLENBQUMsQ0FBQztBQUNKLENBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtzdGRkZXZ9IGZyb20gJ0Bqb25haHNuaWRlci91dGlsJztcbmltcG9ydCB7Y29udmVyc2lvbnN9IGZyb20gJ2J1bmRsZWQtY29udmVyc2lvbnMnO1xuaW1wb3J0IHR5cGUge0luZGV4ZXN9IGZyb20gJ29wdGltaXplZC1jb252ZXJzaW9ucyc7XG5pbXBvcnQge3Byb2QsIGRldn0gZnJvbSAnLi4vdGVzdC9jb252ZXJ0JztcbmltcG9ydCB7YXNzZXJ0Q29udmVyc2lvbnN9IGZyb20gJy4uL3Rlc3QvYXNzZXJ0LWNvbnZlcnNpb24nO1xuaW1wb3J0IHt0ZXN0V2l0aEJ1aWxkc30gZnJvbSAnLi4vdGVzdC93aXRoLWJ1aWxkcyc7XG5pbXBvcnQgdHlwZSB7VW5pdH0gZnJvbSAnLi9pbmRleCc7XG5cbmNvbnN0IGludmFsaWRVbml0ID0gJ25vdCBhIHZhbGlkIHVuaXQnO1xuXG4vKipcbiAqIE1hbnVhbGx5IGRlZmluaW5nIHRoaXMgdmFsdWUgaXMgcmVxdWlyZWQgaW5zdGVhZCBvZiB1c2luZyBgSW5kZXhlcy5Db252ZXJzaW9uLkZhbWlseWAuXG4gKiBUaGlzIGlzIGJlY2F1c2UgZWl0aGVyIEplc3QncyBjdXN0b20gbW9kdWxlIHJlc29sdmVyLCB0aGVpciBCYWJlbCBzZXR1cCwgb3IgYSBtaXggb2YgYm90aCBkb2Vzbid0IHByb3Blcmx5IGhhbmRsZSB0aGUgYGNvbnN0IGVudW1gcy5cbiAqIEluc3RlYWQgb2YgbWFnaWNhbGx5IHVzaW5nIHRoZSBUeXBlU2NyaXB0IHNvdXJjZSB0byBnZXQgdGhlIGVudW0gdmFsdWVzIGl0IHVzZXMgdGhlIGVtaXR0ZWQgY29kZSwgd2hpY2ggaXMgdW5kZWZpbmVkLlxuICpcbiAqIFRoZSBsb25nLXRlcm0gc29sdXRpb24gdG8gdGhpcyBpcyB0byBzaW1wbHkgc3RvcCB1c2luZyBgY29uc3QgZW51bWBzIHdoZW4gZXhwb3J0aW5nIGFjcm9zcyBwYWNrYWdlIGJvdW5kYXJpZXMuXG4gKiBVbmZvcnR1bmF0ZWx5LCBUZXJzZXIgZG9lc24ndCBjb25zdGFudC1mb2xkIHRoZSBlbWl0dGVkIDItd2F5IGxvb2t1cCB0YWJsZSB0aGF0IFR5cGVTY3JpcHQgZW1pdHMgZm9yIGBlbnVtYCBleHByZXNzaW9ucy5cbiAqIEEgZmVhdHVyZSByZXF1ZXN0IGZvciB0aGlzIGhhcyBiZWVuIG9wZW5lZCBvbiB0aGUgVGVyc2VyIHJlcG9zaXRvcnk6IGh0dHBzOi8vZ2l0aHViLmNvbS90ZXJzZXIvdGVyc2VyL2lzc3Vlcy8xMDY0LlxuICovXG5jb25zdCBJTkRFWEVTX0NPTlZFUlNJT05fRkFNSUxZOiBJbmRleGVzLkNvbnZlcnNpb24uRmFtaWx5ID0gMDtcblxuZGVzY3JpYmUoJ2Vycm9ycycsICgpID0+IHtcblx0ZGVzY3JpYmUoJ3Byb2R1Y3Rpb24nLCAoKSA9PiB7XG5cdFx0dGVzdCgncXVhbnRpdHkgdHlwZScsICgpID0+IHtcblx0XHRcdGV4cGVjdCgoKSA9PiBwcm9kLmNvbnZlcnQoJzEyMycgYXMgYW55LCAnbWV0ZXJzJykpLnRvVGhyb3cobmV3IFR5cGVFcnJvcignJykpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcblx0XHRleHBlY3QoKCkgPT4gcHJvZC5jb252ZXJ0KDEyMywgaW52YWxpZFVuaXQgYXMgYW55KSkudG9UaHJvdyhuZXcgUmFuZ2VFcnJvcignJykpO1xuXG5cdFx0ZXhwZWN0KCgpID0+XG5cdFx0XHRwcm9kXG5cdFx0XHRcdC5jb252ZXJ0KDEyMywgJ21zJylcblx0XHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciBJbnZhbGlkIHVuaXRcblx0XHRcdFx0LnRvKGludmFsaWRVbml0KSxcblx0XHQpLnRvVGhyb3coVHlwZUVycm9yKTtcblxuXHRcdGV4cGVjdCgoKSA9PlxuXHRcdFx0cHJvZFxuXHRcdFx0XHQuY29udmVydCgxMDAwLCAnbXMnKVxuXHRcdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIEludmFsaWQgdW5pdFxuXHRcdFx0XHQudG8oJ21ldGVycycpLFxuXHRcdCkudG9UaHJvdyhuZXcgUmFuZ2VFcnJvcignJykpO1xuXG5cdFx0ZXhwZWN0KCgpID0+IHByb2QuY29udmVydCgxMDAwbiwgJ21zJykudG8oJ3NlY29uZHMnKSkudG9UaHJvdyhcblx0XHRcdG5ldyBSYW5nZUVycm9yKCdUaGUgbnVtYmVyIDAuMDAxIGNhbm5vdCBiZSBjb252ZXJ0ZWQgdG8gYSBCaWdJbnQgYmVjYXVzZSBpdCBpcyBub3QgYW4gaW50ZWdlcicpLFxuXHRcdCk7XG5cblx0XHR0ZXN0KCdpbnZhbGlkIGJlc3QgdW5pdCBraW5kJywgKCkgPT4ge1xuXHRcdFx0ZXhwZWN0KCgpID0+XG5cdFx0XHRcdHByb2QuY29udmVydCgxMjMsICdpbicpLnRvKFxuXHRcdFx0XHRcdCdiZXN0Jyxcblx0XHRcdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIEludmFsaWQgYmVzdCBraW5kXG5cdFx0XHRcdFx0J2ludmFsaWQnLFxuXHRcdFx0XHQpLFxuXHRcdFx0KS50b1Rocm93KG5ldyBSYW5nZUVycm9yKCcnKSk7XG5cdFx0fSk7XG5cdH0pO1xuXG5cdGRlc2NyaWJlKCdkZXZlbG9wbWVudCcsICgpID0+IHtcblx0XHR0ZXN0LmVhY2goW1xuXHRcdFx0Ly8gUXVhbnRpdHkgdHlwZVxuXHRcdFx0e2ZuOiAoKSA9PiBkZXYuY29udmVydCgnMTIzJyBhcyBhbnksICdtZXRlcnMnKSwgZXJyb3I6IFR5cGVFcnJvcn0sXG5cblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG5cdFx0XHR7Zm46ICgpID0+IGRldi5jb252ZXJ0KDEyMywgaW52YWxpZFVuaXQgYXMgYW55KSwgZXJyb3I6IFJhbmdlRXJyb3J9LFxuXHRcdFx0e1xuXHRcdFx0XHRmbjogKCkgPT5cblx0XHRcdFx0XHRkZXZcblx0XHRcdFx0XHRcdC5jb252ZXJ0KDEwMDAsICdtcycpXG5cdFx0XHRcdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIEludmFsaWQgdW5pdFxuXHRcdFx0XHRcdFx0LnRvKGludmFsaWRVbml0KSxcblx0XHRcdFx0ZXJyb3I6IFJhbmdlRXJyb3IsXG5cdFx0XHR9LFxuXG5cdFx0XHR7XG5cdFx0XHRcdGZuOiAoKSA9PlxuXHRcdFx0XHRcdGRldlxuXHRcdFx0XHRcdFx0LmNvbnZlcnQoMTAwMCwgJ21zJylcblx0XHRcdFx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgSW52YWxpZCB1bml0XG5cdFx0XHRcdFx0XHQudG8oJ21ldGVycycpLFxuXHRcdFx0XHRlcnJvcjogUmFuZ2VFcnJvcixcblx0XHRcdH0sXG5cblx0XHRcdC8vIEludmFsaWQgYmVzdCB1bml0IGtpbmRcblx0XHRcdHtcblx0XHRcdFx0Zm46ICgpID0+XG5cdFx0XHRcdFx0ZGV2LmNvbnZlcnQoMTIzLCAnaW4nKS50byhcblx0XHRcdFx0XHRcdCdiZXN0Jyxcblx0XHRcdFx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgSW52YWxpZCBiZXN0IGtpbmRcblx0XHRcdFx0XHRcdCdpbnZhbGlkJyxcblx0XHRcdFx0XHQpLFxuXHRcdFx0XHRlcnJvcjogUmFuZ2VFcnJvcixcblx0XHRcdH0sXG5cdFx0XSkoJyVwJywgKHtmbiwgZXJyb3J9KSA9PiB7XG5cdFx0XHRleHBlY3QoZm4pLnRvVGhyb3coZXJyb3IpO1xuXHRcdFx0ZXhwZWN0KGZuKS50b1Rocm93KC8uKy8pO1xuXHRcdH0pO1xuXG5cdFx0ZXhwZWN0KCgpID0+XG5cdFx0XHRkZXZcblx0XHRcdFx0LmNvbnZlcnQoMTIzLCAnbXMnKVxuXHRcdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIEludmFsaWQgdW5pdFxuXHRcdFx0XHQudG8oJ20nKSxcblx0XHQpLnRvVGhyb3coXG5cdFx0XHRuZXcgUmFuZ2VFcnJvcihcblx0XHRcdFx0J05vIGNvbnZlcnNpb24gY291bGQgYmUgZm91bmQgZnJvbSBtcyB0byBtLiBBbHNvLCBhcmUgeW91IHRyeWluZyB0byBjb252ZXJ0IHF1YW50aXRpZXMgb2YgdGltZT8gQmVjYXVzZSBcIm1cIiBpcyB0cmVhdGVkIGFzIG1ldGVycywgbm90IG1pbnV0ZXMuIFlvdSBwcm9iYWJseSB3YW50IHRvIHVzZSB0aGUgXCJtaW5cIiB1bml0IGluc3RlYWQuJyxcblx0XHRcdCksXG5cdFx0KTtcblxuXHRcdGV4cGVjdCgoKSA9PiBkZXYuY29udmVydCgxMDAwbiwgJ21zJykudG8oJ3NlY29uZHMnKSkudG9UaHJvdyhcblx0XHRcdG5ldyBSYW5nZUVycm9yKCdDb252ZXJzaW9uIGZvciBtcyB0byBzZWNvbmRzIGNhbm5vdCBiZSBjYWxjdWxhdGVkIGFzIGEgQmlnSW50IGJlY2F1c2UgdGhlIGNvbnZlcnNpb24gcmF0aW8gaXMgbm90IGFuIGludGVnZXInKSxcblx0XHQpO1xuXHR9KTtcbn0pO1xuXG5hc3NlcnRDb252ZXJzaW9ucyhbXG5cdHtmcm9tOiBbMSwgJ3NlY29uZCddLCB0bzogWzEsICdzZWNvbmQnXX0sXG5cdHtmcm9tOiBbMm4sICdob3VycyddLCB0bzogWzEyMG4sICdtaW51dGUnXX0sXG5dKTtcblxuZGVzY3JpYmUoJ3JvdW5kdHJpcCBjb252ZXJzaW9uJywgKCkgPT4ge1xuXHRkZXNjcmliZS5lYWNoPFVuaXQ+KFsnbTInLCAnYicsICdCJywgJ04nLCAncGRsJywgJ20nLCAnZycsICdQYScsICdLJywgJ3MnLCAnbTMnXSkoJyVwJywgYmFzZVVuaXQgPT4ge1xuXHRcdGNvbnN0IGRlc2lyZWRGYW1pbHlJZCA9IGNvbnZlcnNpb25zW2Jhc2VVbml0XVtJTkRFWEVTX0NPTlZFUlNJT05fRkFNSUxZXTtcblxuXHRcdHRlc3QuZWFjaChPYmplY3QuZW50cmllcyhjb252ZXJzaW9ucykpKGAke2Jhc2VVbml0fSA8LT4gJDBgLCAodW5pdCwgZGF0YSkgPT4ge1xuXHRcdFx0aWYgKCFkYXRhKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZmFtaWx5SWQgPSBkYXRhW0lOREVYRVNfQ09OVkVSU0lPTl9GQU1JTFldO1xuXG5cdFx0XHRpZiAoZmFtaWx5SWQgIT09IGRlc2lyZWRGYW1pbHlJZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHZhbHVlID0gMTIzO1xuXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuXHRcdFx0Y29uc3QgYVRvQiA9IHByb2QuY29udmVydCh2YWx1ZSwgYmFzZVVuaXQgYXMgYW55KS50byh1bml0IGFzIGFueSkgYXMgdW5rbm93biBhcyBudW1iZXI7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuXHRcdFx0Y29uc3QgYlRvQSA9IHByb2QuY29udmVydChhVG9CLCB1bml0IGFzIGFueSkudG8oYmFzZVVuaXQgYXMgYW55KSBhcyB1bmtub3duIGFzIG51bWJlcjtcblxuXHRcdFx0Y29uc3QgZGlmZmVyZW5jZSA9IHN0ZGRldihbdmFsdWUsIGJUb0FdKTtcblxuXHRcdFx0aWYgKGRpZmZlcmVuY2UgIT09IDApIHtcblx0XHRcdFx0Ly8gTm90IHN1cmUgZXhhY3RseSB3aHkgdGhpcyB2YWx1ZSBrZWVwcyBzaG93aW5nIHVwXG5cdFx0XHRcdGV4cGVjdChkaWZmZXJlbmNlKS50b0JlQ2xvc2VUbygwLCAxMyk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xufSk7XG5cbmRlc2NyaWJlKCdwcmVjaXNpb24gbG9zcyBmcm9tIGNvbnZlcnRpbmcgdG8gYmVzdCcsICgpID0+IHtcblx0YXNzZXJ0Q29udmVyc2lvbnMoW3tmcm9tOiBbMS41LCAnZGF5cyddLCB0bzogWzEuNSwgJ2QnXX1dKTtcblxuXHR0ZXN0V2l0aEJ1aWxkcyhtb2QgPT4ge1xuXHRcdGNvbnN0IHJlc3VsdCA9IG1vZC5jb252ZXJ0KDEuNSwgJ2RheXMnKS50bygnYmVzdCcpO1xuXG5cdFx0ZXhwZWN0KHJlc3VsdC51bml0KS50b0JlKCdkJyk7XG5cblx0XHQvLyBOb3RlOiB0aGlzIHVzZWQgdG8gbm90IHJldHVybiAxLjUsIGJ1dCBhZnRlciBjaGFuZ2luZyB0aGUgc21hbGxlc3QgYmVzdCB1bml0IGZyb20gbnMgdG8gZnMgaXQgZml4ZWQgaXRzZWxmXG5cdFx0Ly8gVGhpcyBpcyBiZWNhdXNlIG9mIGFyaXRobWV0aWMgcHJlY2lzaW9uIGxpbWl0YXRpb25zIGZvciA2NC1iaXQgZmxvYXRzLCB3aGljaCBhcmUgdXNlZCB0byByZXByZXNlbnQgdGhlIHJhdGlvIHVzZWQgZm9yIHNlY29uZHMgKDMuMTUzNmUrMjIpXG5cdFx0ZXhwZWN0KHJlc3VsdC5xdWFudGl0eSkudG9CZSgxLjUpO1xuXHRcdGV4cGVjdChyZXN1bHQudG9TdHJpbmcoKSkudG9CZSgnMS41ZCcpO1xuXG5cdFx0ZXhwZWN0KHJlc3VsdC5xdWFudGl0eSkudG9CZSgxLjUpO1xuXHRcdGV4cGVjdChyZXN1bHQudG9TdHJpbmcoKSkudG9CZShgJHsxLjV9ZGApO1xuXHR9KTtcbn0pO1xuXG5kZXNjcmliZSgnY29udmVydGluZyB0byBiZXN0IHdpdGggcm91bmRpbmcnLCAoKSA9PiB7XG5cdGRlc2NyaWJlKCd3b3JrcyB3aGVuIHJlbW92aW5nIGRlY2ltYWwgcGxhY2VzJywgKCkgPT4ge1xuXHRcdHRlc3RXaXRoQnVpbGRzKG1vZCA9PiB7XG5cdFx0XHRleHBlY3QobW9kLmNvbnZlcnQoMTIzXzQ1NiwgJ20nKS50bygnYmVzdCcpLnRvU3RyaW5nKDIpKS50b0JlKCcxMjMuNDZrbScpO1xuXHRcdFx0ZXhwZWN0KG1vZC5jb252ZXJ0KDEyM180NTYsICdtJykudG8oJ2Jlc3QnKS50b1N0cmluZygwKSkudG9CZSgnMTIza20nKTtcblx0XHRcdGV4cGVjdChtb2QuY29udmVydCgxMDAwLCAnbWljcm9tZXRlcicpLnRvKCdiZXN0JykudG9TdHJpbmcoMSkpLnRvQmUoJzEuMG1tJyk7XG5cdFx0XHRleHBlY3QobW9kLmNvbnZlcnQoMTAwMCwgJ21pY3JvbWV0ZXInKS50bygnYmVzdCcpLnRvU3RyaW5nKDApKS50b0JlKCcxbW0nKTtcblx0XHR9KTtcblx0fSk7XG5cblx0ZGVzY3JpYmUoJ3dvcmtzIHdoZW4gYWRkaW5nIGRlY2ltYWwgcGxhY2VzJywgKCkgPT4ge1xuXHRcdHRlc3RXaXRoQnVpbGRzKG1vZCA9PiB7XG5cdFx0XHRleHBlY3QobW9kLmNvbnZlcnQoMTAwMCwgJ20nKS50bygnYmVzdCcpLnRvU3RyaW5nKDQpKS50b0JlKCcxLjAwMDBrbScpO1xuXHRcdFx0ZXhwZWN0KG1vZC5jb252ZXJ0KDEwMDAsICdtJykudG8oJ2Jlc3QnKS50b1N0cmluZygwKSkudG9CZSgnMWttJyk7XG5cdFx0XHRleHBlY3QobW9kLmNvbnZlcnQoMTAwMCwgJ21pY3JvbWV0ZXInKS50bygnYmVzdCcpLnRvU3RyaW5nKDQpKS50b0JlKCcxLjAwMDBtbScpO1xuXHRcdFx0ZXhwZWN0KG1vZC5jb252ZXJ0KDEwMDAsICdtaWNyb21ldGVyJykudG8oJ2Jlc3QnKS50b1N0cmluZygwKSkudG9CZSgnMW1tJyk7XG5cdFx0fSk7XG5cdH0pO1xuXG5cdGRlc2NyaWJlKCdkb2VzIG5vdGhpbmcgd2hlbiBvbWl0dGVkJywgKCkgPT4ge1xuXHRcdHRlc3RXaXRoQnVpbGRzKG1vZCA9PiB7XG5cdFx0XHRleHBlY3QobW9kLmNvbnZlcnQoMTIzXzQ1NiwgJ20nKS50bygnYmVzdCcpLnRvU3RyaW5nKCkpLnRvQmUoJzEyMy40NTU5OTk5OTk5OTk5OWttJyk7XG5cdFx0XHRleHBlY3QobW9kLmNvbnZlcnQoMTIzXzQ1NiwgJ20nKS50bygnYmVzdCcpLnRvU3RyaW5nKHVuZGVmaW5lZCkpLnRvQmUoJzEyMy40NTU5OTk5OTk5OTk5OWttJyk7XG5cdFx0XHRleHBlY3QobW9kLmNvbnZlcnQoMTAwMCwgJ21pY3JvbWV0ZXInKS50bygnYmVzdCcpLnRvU3RyaW5nKCkpLnRvQmUoJzFtbScpO1xuXHRcdFx0ZXhwZWN0KG1vZC5jb252ZXJ0KDEwMDAsICdtaWNyb21ldGVyJykudG8oJ2Jlc3QnKS50b1N0cmluZyh1bmRlZmluZWQpKS50b0JlKCcxbW0nKTtcblx0XHR9KTtcblx0fSk7XG59KTtcbiJdfQ==