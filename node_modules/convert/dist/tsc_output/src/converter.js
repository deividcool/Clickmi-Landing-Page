import { KelvinNames } from 'conversions';
import { bestUnits, conversions, temperatureDifferences } from 'bundled-conversions';
import * as Conversions from 'conversions';
import { Indexes } from 'optimized-conversions';
import { convert } from './convert.js';
import { assert, assertType, isType } from './assert.js';
// eslint-disable-next-line complexity
export function to(to, kind = 'metric') {
    if (this._from === to) {
        // This is ok since we have already validated the type of quantity
        return this._quantity;
    }
    // TODO: Extract to function
    if (to === 'best') {
        // eslint-disable-next-line no-prototype-builtins
        if (!bestUnits.hasOwnProperty(kind)) {
            if (__DEV__) {
                throw new RangeError(`${kind} is not a valid best conversion kind`);
            }
            throw new RangeError();
        }
        const bestUnitKind = bestUnits[kind];
        const family = bestUnitKind[this._fromUnit[Indexes.Conversion.Family]];
        const baseUnit = family[0][Indexes.Best.Sym];
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        let quantity = convert(this._quantity, this._from).to(baseUnit);
        const absQuantity = quantity < 0 ? -quantity : quantity;
        let bestUnit = baseUnit;
        // eslint-disable-next-line unicorn/no-for-loop, @typescript-eslint/prefer-for-of
        for (let i = 0; i < family.length; i++) {
            const best = family[i];
            if (absQuantity >= best[Indexes.Best.Value]) {
                bestUnit = best[Indexes.Best.Sym];
            }
        }
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        quantity = convert(quantity, baseUnit).to(bestUnit);
        return {
            quantity,
            unit: bestUnit,
            toString: this._isUsingBigInts
                ? () => (quantity + bestUnit)
                : (toFixed) => ((toFixed === undefined ? quantity : quantity.toFixed(toFixed)) + bestUnit),
        };
    }
    const toUnit = conversions[to];
    if (__DEV__) {
        if (!toUnit) {
            throw new RangeError(`${to} is not a valid unit`);
        }
        const meters = 'm';
        if (
        // Time -> meters
        (this._fromUnit[Indexes.Conversion.Family] === Conversions.Id.Time && to === meters) ||
            // Meters -> time
            (toUnit[Indexes.Conversion.Family] === Conversions.Id.Time && this._from === meters)) {
            throw new RangeError([
                `No conversion could be found from ${this._from} to ${to}.`,
                'Also, are you trying to convert quantities of time?',
                'Because "m" is treated as meters, not minutes.',
                'You probably want to use the "min" unit instead.',
            ].join(' '));
        }
    }
    // @ts-expect-error This throws if toUnit is undefined
    if (this._fromUnit[Indexes.Conversion.Family] !== toUnit[Indexes.Conversion.Family]) {
        if (__DEV__) {
            throw new RangeError(`No conversion could be found from ${this._from} to ${to}`);
        }
        throw new RangeError();
    }
    assert(toUnit);
    if (this._isUsingBigInts && isType(this._quantity)) {
        // TODO: If quantity is a bigint return a different Converter<T> instead of checking it here - this may not increase performance if TurboFan is already optimizing for different code paths
        if (__DEV__) {
            try {
                BigInt(this._fromUnit[Indexes.Conversion.Ratio] / toUnit[Indexes.Conversion.Ratio]);
            }
            catch {
                throw new TypeError(`Conversion for ${this._from} to ${to} cannot be calculated as a BigInt because the conversion ratio is not an integer`);
            }
        }
        if (this._from in temperatureDifferences || to in temperatureDifferences) {
            if (__DEV__) {
                const reason = this._from in temperatureDifferences ? this._from : to;
                throw new RangeError(`Conversion for ${this._from} to ${to} cannot be calculated as ${reason} has a conversion difference which cannot be converted with bigints`);
            }
            throw new RangeError();
        }
        // Difference is intentionally excluded as there is never a case where you could convert a temperature to a different temperature as integers
        return (this._quantity *
            // Converting each ratio to bigints would make the most sense here but it ends up with unhelpful return values (ex. 1_000_000n B -> MB === 0n instead of 1n)
            // It's mostly okay to do this since ratios are already `number`s so we aren't losing a ton of precision, just if you have 2 very precise ratios that are multiplied together and exceed the precision of a `number`
            BigInt(this._fromUnit[Indexes.Conversion.Ratio] / toUnit[Indexes.Conversion.Ratio]));
    }
    assertType(this._quantity);
    if (this._isConvertingTemperature && isType(this._from) && isType(to)) {
        switch (to) {
            case KelvinNames.K:
            case KelvinNames.kelvin:
            case KelvinNames.kelvins: {
                if (this._from in temperatureDifferences && isType(this._from)) {
                    return ((this._quantity + temperatureDifferences[this._from]) * this._fromUnit[Indexes.Conversion.Ratio]);
                }
                return (this._quantity * this._fromUnit[Indexes.Conversion.Ratio]);
            }
            default: {
                break;
            }
        }
        switch (this._from) {
            case KelvinNames.K:
            case KelvinNames.kelvin:
            case KelvinNames.kelvins: {
                if (to in temperatureDifferences && isType(to)) {
                    return (this._quantity / toUnit[Indexes.Conversion.Ratio] - temperatureDifferences[to]);
                }
                return (this._quantity / toUnit[Indexes.Conversion.Ratio]);
            }
            default: {
                break;
            }
        }
        return convert(convert(this._quantity, this._from).to('K'), 'K').to(to);
    }
    return (this._quantity * (this._fromUnit[Indexes.Conversion.Ratio] / toUnit[Indexes.Conversion.Ratio]));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udmVydGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbnZlcnRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUMsV0FBVyxFQUFDLE1BQU0sYUFBYSxDQUFDO0FBQ3hDLE9BQU8sRUFBQyxTQUFTLEVBQUUsV0FBVyxFQUFFLHNCQUFzQixFQUFDLE1BQU0scUJBQXFCLENBQUM7QUFDbkYsT0FBTyxLQUFLLFdBQVcsTUFBTSxhQUFhLENBQUM7QUFDM0MsT0FBTyxFQUFDLE9BQU8sRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBQzlDLE9BQU8sRUFBQyxPQUFPLEVBQUMsTUFBTSxjQUFjLENBQUM7QUFHckMsT0FBTyxFQUFDLE1BQU0sRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFDLE1BQU0sYUFBYSxDQUFDO0FBaUN2RCxzQ0FBc0M7QUFDdEMsTUFBTSxVQUFVLEVBQUUsQ0FFakIsRUFBYyxFQUNkLE9BQThCLFFBQVE7SUFFdEMsSUFBSSxJQUFJLENBQUMsS0FBSyxLQUFLLEVBQUUsRUFBRTtRQUN0QixrRUFBa0U7UUFFbEUsT0FBTyxJQUFJLENBQUMsU0FBMkMsQ0FBQztLQUN4RDtJQUVELDRCQUE0QjtJQUM1QixJQUFJLEVBQUUsS0FBSyxNQUFNLEVBQUU7UUFDbEIsaURBQWlEO1FBQ2pELElBQUksQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ3BDLElBQUksT0FBTyxFQUFFO2dCQUNaLE1BQU0sSUFBSSxVQUFVLENBQUMsR0FBRyxJQUFJLHNDQUFzQyxDQUFDLENBQUM7YUFDcEU7WUFFRCxNQUFNLElBQUksVUFBVSxFQUFFLENBQUM7U0FDdkI7UUFFRCxNQUFNLFlBQVksR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDckMsTUFBTSxNQUFNLEdBQUcsWUFBWSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENB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LE1BQU0sQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxHQUFHLHNCQUFzQixDQUFDLEVBQUUsQ0FBQyxDQUFtQyxDQUFDO2lCQUMxSDtnQkFFRCxPQUFPLENBQUMsSUFBSSxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBbUMsQ0FBQzthQUM3RjtZQUVELE9BQU8sQ0FBQyxDQUFDO2dCQUNSLE1BQU07YUFDTjtTQUNEO1FBRUQsT0FBTyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFtQyxDQUFDO0tBQzFHO0lBRUQsT0FBTyxDQUFDLElBQUksQ0FBQyxTQUFTLEdBQUcsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBbUMsQ0FBQztBQUMzSSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtLZWx2aW5OYW1lc30gZnJvbSAnY29udmVyc2lvbnMnO1xuaW1wb3J0IHtiZXN0VW5pdHMsIGNvbnZlcnNpb25zLCB0ZW1wZXJhdHVyZURpZmZlcmVuY2VzfSBmcm9tICdidW5kbGVkLWNvbnZlcnNpb25zJztcbmltcG9ydCAqIGFzIENvbnZlcnNpb25zIGZyb20gJ2NvbnZlcnNpb25zJztcbmltcG9ydCB7SW5kZXhlc30gZnJvbSAnb3B0aW1pemVkLWNvbnZlcnNpb25zJztcbmltcG9ydCB7Y29udmVydH0gZnJvbSAnLi9jb252ZXJ0LmpzJztcbmltcG9ydCB0eXBlIHtCZXN0Q29udmVyc2lvbiwgQmVzdFVuaXRzLCBTaW1wbGlmeVF1YW50aXR5fSBmcm9tICcuL3R5cGVzL2NvbW1vbi5qcyc7XG5pbXBvcnQgdHlwZSB7VGVtcGVyYXR1cmUsIFVuaXQsIFVuaXRUb0ZhbWlseX0gZnJvbSAnLi90eXBlcy91bml0cy5qcyc7XG5pbXBvcnQge2Fzc2VydCwgYXNzZXJ0VHlwZSwgaXNUeXBlfSBmcm9tICcuL2Fzc2VydC5qcyc7XG5cbnR5cGUgVGVtcGVyYXR1cmVXaXRoRGlmZmVyZW5jZSA9IEV4Y2x1ZGU8a2V5b2YgdHlwZW9mIHRlbXBlcmF0dXJlRGlmZmVyZW5jZXMsICdfX3Byb3RvX18nPjtcblxudHlwZSBDb252ZXJ0ZXJUaGlzPFEgZXh0ZW5kcyBudW1iZXIgfCBiaWdpbnQsIFUgZXh0ZW5kcyBVbml0PiA9IHtcblx0X3F1YW50aXR5OiBRO1xuXHRfZnJvbTogVTtcblx0X2Zyb21Vbml0OiAodHlwZW9mIGNvbnZlcnNpb25zKVtVXTtcblx0X2lzVXNpbmdCaWdJbnRzOiBRIGV4dGVuZHMgYmlnaW50ID8gdHJ1ZSA6IGZhbHNlO1xuXHRfaXNDb252ZXJ0aW5nVGVtcGVyYXR1cmU6IFUgZXh0ZW5kcyBUZW1wZXJhdHVyZSA/IHRydWUgOiBmYWxzZTtcbn07XG5cbi8qKlxuICogQ29udmVydCBhIG1lYXN1cmVtZW50IHRvIHRoZSBiZXN0IHVuaXQgZm9yIGRpc3BsYXkuXG4gKlxuICogQHBhcmFtIHRvIC0gVGhlIHN0cmluZyBgYmVzdGBcbiAqIEBwYXJhbSBraW5kIC0gVGhlIHNldCBvZiB1bml0cyB0byB1c2UgKGRlZmF1bHRzIHRvIGAnbWV0cmljJ2ApXG4gKlxuICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggYSBgcXVhbnRpdHlgIHByb3BlcnR5IG9mIHRoZSBgdW5pdGAgdW5pdCwgd2hpY2ggY2FuIGJlIGNhc3RlZCB0byBhIHN0cmluZyB1c2luZyB0aGUgYHRvU3RyaW5nKClgIG1ldGhvZFxuICovXG5leHBvcnQgZnVuY3Rpb24gdG88USBleHRlbmRzIG51bWJlciB8IGJpZ2ludCwgVSBleHRlbmRzIFVuaXQsIEsgZXh0ZW5kcyBDb252ZXJzaW9ucy5CZXN0LktpbmQgPSBDb252ZXJzaW9ucy5CZXN0LktpbmQ+KFxuXHR0aGlzOiBDb252ZXJ0ZXJUaGlzPFEsIFU+LFxuXHR0bzogJ2Jlc3QnLFxuXHRraW5kPzogSyB8IHVuZGVmaW5lZCxcbik6IEJlc3RDb252ZXJzaW9uPFEsIEJlc3RVbml0czxVbml0VG9GYW1pbHlbVV0sIEs+Pjtcbi8qKlxuICogQ29udmVydCBhIHF1YW50aXR5IG9mIG9uZSB1bml0IGludG8gYSBuZXcgdW5pdFxuICpcbiAqIEBwYXJhbSB0byAtIFRoZSB1bml0IHlvdSB3YW50IHRvIGNvbnZlcnQgdG9cbiAqXG4gKiBAcmV0dXJucyBUaGUgY29udmVydGVkIHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0bzxRIGV4dGVuZHMgbnVtYmVyIHwgYmlnaW50LCBVIGV4dGVuZHMgVW5pdD4odGhpczogQ29udmVydGVyVGhpczxRLCBVPiwgdG86IFUpOiBTaW1wbGlmeVF1YW50aXR5PFE+O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmV4cG9ydCBmdW5jdGlvbiB0bzxRIGV4dGVuZHMgbnVtYmVyIHwgYmlnaW50LCBVIGV4dGVuZHMgVW5pdCwgSyBleHRlbmRzIENvbnZlcnNpb25zLkJlc3QuS2luZCA9IENvbnZlcnNpb25zLkJlc3QuS2luZD4oXG5cdHRoaXM6IENvbnZlcnRlclRoaXM8USwgVT4sXG5cdHRvOiBVIHwgJ2Jlc3QnLFxuXHRraW5kOiBDb252ZXJzaW9ucy5CZXN0LktpbmQgPSAnbWV0cmljJyxcbik6IFNpbXBsaWZ5UXVhbnRpdHk8UT4gfCBCZXN0Q29udmVyc2lvbjxRLCBCZXN0VW5pdHM8VW5pdFRvRmFtaWx5W1VdLCBLPj4ge1xuXHRpZiAodGhpcy5fZnJvbSA9PT0gdG8pIHtcblx0XHQvLyBUaGlzIGlzIG9rIHNpbmNlIHdlIGhhdmUgYWxyZWFkeSB2YWxpZGF0ZWQgdGhlIHR5cGUgb2YgcXVhbnRpdHlcblxuXHRcdHJldHVybiB0aGlzLl9xdWFudGl0eSBhcyB1bmtub3duIGFzIFNpbXBsaWZ5UXVhbnRpdHk8UT47XG5cdH1cblxuXHQvLyBUT0RPOiBFeHRyYWN0IHRvIGZ1bmN0aW9uXG5cdGlmICh0byA9PT0gJ2Jlc3QnKSB7XG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuXHRcdGlmICghYmVzdFVuaXRzLmhhc093blByb3BlcnR5KGtpbmQpKSB7XG5cdFx0XHRpZiAoX19ERVZfXykge1xuXHRcdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJHtraW5kfSBpcyBub3QgYSB2YWxpZCBiZXN0IGNvbnZlcnNpb24ga2luZGApO1xuXHRcdFx0fVxuXG5cdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcigpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGJlc3RVbml0S2luZCA9IGJlc3RVbml0c1traW5kXTtcblx0XHRjb25zdCBmYW1pbHkgPSBiZXN0VW5pdEtpbmRbdGhpcy5fZnJvbVVuaXRbSW5kZXhlcy5Db252ZXJzaW9uLkZhbWlseV1dO1xuXG5cdFx0Y29uc3QgYmFzZVVuaXQgPSBmYW1pbHlbMF1bSW5kZXhlcy5CZXN0LlN5bV07XG5cblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuXHRcdGxldCBxdWFudGl0eSA9IGNvbnZlcnQodGhpcy5fcXVhbnRpdHksIHRoaXMuX2Zyb20gYXMgYW55KS50byhiYXNlVW5pdCBhcyBhbnkpIGFzIHVua25vd24gYXMgU2ltcGxpZnlRdWFudGl0eTxRPjtcblx0XHRjb25zdCBhYnNRdWFudGl0eSA9IHF1YW50aXR5IDwgMCA/IC1xdWFudGl0eSA6IHF1YW50aXR5O1xuXG5cdFx0bGV0IGJlc3RVbml0OiAodHlwZW9mIGZhbWlseSlbbnVtYmVyXVtJbmRleGVzLkJlc3QuU3ltXSA9IGJhc2VVbml0O1xuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vbm8tZm9yLWxvb3AsIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItZm9yLW9mXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBmYW1pbHkubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IGJlc3QgPSBmYW1pbHlbaV07XG5cdFx0XHRpZiAoYWJzUXVhbnRpdHkgPj0gYmVzdFtJbmRleGVzLkJlc3QuVmFsdWVdKSB7XG5cdFx0XHRcdGJlc3RVbml0ID0gYmVzdFtJbmRleGVzLkJlc3QuU3ltXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuXHRcdHF1YW50aXR5ID0gY29udmVydChxdWFudGl0eSwgYmFzZVVuaXQgYXMgYW55KS50byhiZXN0VW5pdCBhcyBhbnkpIGFzIHVua25vd24gYXMgU2ltcGxpZnlRdWFudGl0eTxRPjtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRxdWFudGl0eSxcblx0XHRcdHVuaXQ6IGJlc3RVbml0LFxuXHRcdFx0dG9TdHJpbmc6IHRoaXMuX2lzVXNpbmdCaWdJbnRzXG5cdFx0XHRcdD8gKCkgPT4gKChxdWFudGl0eSBhcyBiaWdpbnQpICsgYmVzdFVuaXQpIGFzIGAke1NpbXBsaWZ5UXVhbnRpdHk8UT59JHtCZXN0VW5pdHM8VW5pdFRvRmFtaWx5W1VdLCBLPn1gXG5cdFx0XHRcdDogKHRvRml4ZWQ/OiBudW1iZXIpID0+XG5cdFx0XHRcdFx0XHQoKHRvRml4ZWQgPT09IHVuZGVmaW5lZCA/IHF1YW50aXR5IDogKHF1YW50aXR5IGFzIG51bWJlcikudG9GaXhlZCh0b0ZpeGVkKSkgKyBiZXN0VW5pdCkgYXMgYCR7U2ltcGxpZnlRdWFudGl0eTxRPn0ke0Jlc3RVbml0czxVbml0VG9GYW1pbHlbVV0sIEs+fWAsXG5cdFx0fTtcblx0fVxuXG5cdGNvbnN0IHRvVW5pdCA9IGNvbnZlcnNpb25zW3RvXSBhcyAodHlwZW9mIGNvbnZlcnNpb25zKVtrZXlvZiB0eXBlb2YgY29udmVyc2lvbnNdIHwgdW5kZWZpbmVkO1xuXG5cdGlmIChfX0RFVl9fKSB7XG5cdFx0aWYgKCF0b1VuaXQpIHtcblx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKGAke3RvfSBpcyBub3QgYSB2YWxpZCB1bml0YCk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgbWV0ZXJzID0gJ20nO1xuXG5cdFx0aWYgKFxuXHRcdFx0Ly8gVGltZSAtPiBtZXRlcnNcblx0XHRcdCh0aGlzLl9mcm9tVW5pdFtJbmRleGVzLkNvbnZlcnNpb24uRmFtaWx5XSA9PT0gQ29udmVyc2lvbnMuSWQuVGltZSAmJiB0byA9PT0gbWV0ZXJzKSB8fFxuXHRcdFx0Ly8gTWV0ZXJzIC0+IHRpbWVcblx0XHRcdCh0b1VuaXRbSW5kZXhlcy5Db252ZXJzaW9uLkZhbWlseV0gPT09IENvbnZlcnNpb25zLklkLlRpbWUgJiYgdGhpcy5fZnJvbSA9PT0gbWV0ZXJzKVxuXHRcdCkge1xuXHRcdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoXG5cdFx0XHRcdFtcblx0XHRcdFx0XHRgTm8gY29udmVyc2lvbiBjb3VsZCBiZSBmb3VuZCBmcm9tICR7dGhpcy5fZnJvbX0gdG8gJHt0b30uYCxcblx0XHRcdFx0XHQnQWxzbywgYXJlIHlvdSB0cnlpbmcgdG8gY29udmVydCBxdWFudGl0aWVzIG9mIHRpbWU/Jyxcblx0XHRcdFx0XHQnQmVjYXVzZSBcIm1cIiBpcyB0cmVhdGVkIGFzIG1ldGVycywgbm90IG1pbnV0ZXMuJyxcblx0XHRcdFx0XHQnWW91IHByb2JhYmx5IHdhbnQgdG8gdXNlIHRoZSBcIm1pblwiIHVuaXQgaW5zdGVhZC4nLFxuXHRcdFx0XHRdLmpvaW4oJyAnKSxcblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQHRzLWV4cGVjdC1lcnJvciBUaGlzIHRocm93cyBpZiB0b1VuaXQgaXMgdW5kZWZpbmVkXG5cdGlmICh0aGlzLl9mcm9tVW5pdFtJbmRleGVzLkNvbnZlcnNpb24uRmFtaWx5XSAhPT0gdG9Vbml0W0luZGV4ZXMuQ29udmVyc2lvbi5GYW1pbHldKSB7XG5cdFx0aWYgKF9fREVWX18pIHtcblx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKGBObyBjb252ZXJzaW9uIGNvdWxkIGJlIGZvdW5kIGZyb20gJHt0aGlzLl9mcm9tfSB0byAke3RvfWApO1xuXHRcdH1cblxuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKCk7XG5cdH1cblxuXHRhc3NlcnQodG9Vbml0KTtcblxuXHRpZiAodGhpcy5faXNVc2luZ0JpZ0ludHMgJiYgaXNUeXBlPGJpZ2ludD4odGhpcy5fcXVhbnRpdHkpKSB7XG5cdFx0Ly8gVE9ETzogSWYgcXVhbnRpdHkgaXMgYSBiaWdpbnQgcmV0dXJuIGEgZGlmZmVyZW50IENvbnZlcnRlcjxUPiBpbnN0ZWFkIG9mIGNoZWNraW5nIGl0IGhlcmUgLSB0aGlzIG1heSBub3QgaW5jcmVhc2UgcGVyZm9ybWFuY2UgaWYgVHVyYm9GYW4gaXMgYWxyZWFkeSBvcHRpbWl6aW5nIGZvciBkaWZmZXJlbnQgY29kZSBwYXRoc1xuXG5cdFx0aWYgKF9fREVWX18pIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdEJpZ0ludCh0aGlzLl9mcm9tVW5pdFtJbmRleGVzLkNvbnZlcnNpb24uUmF0aW9dIC8gdG9Vbml0W0luZGV4ZXMuQ29udmVyc2lvbi5SYXRpb10pO1xuXHRcdFx0fSBjYXRjaCB7XG5cdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYENvbnZlcnNpb24gZm9yICR7dGhpcy5fZnJvbX0gdG8gJHt0b30gY2Fubm90IGJlIGNhbGN1bGF0ZWQgYXMgYSBCaWdJbnQgYmVjYXVzZSB0aGUgY29udmVyc2lvbiByYXRpbyBpcyBub3QgYW4gaW50ZWdlcmApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9mcm9tIGluIHRlbXBlcmF0dXJlRGlmZmVyZW5jZXMgfHwgdG8gaW4gdGVtcGVyYXR1cmVEaWZmZXJlbmNlcykge1xuXHRcdFx0aWYgKF9fREVWX18pIHtcblx0XHRcdFx0Y29uc3QgcmVhc29uID0gdGhpcy5fZnJvbSBpbiB0ZW1wZXJhdHVyZURpZmZlcmVuY2VzID8gdGhpcy5fZnJvbSA6IHRvO1xuXG5cdFx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKFxuXHRcdFx0XHRcdGBDb252ZXJzaW9uIGZvciAke3RoaXMuX2Zyb219IHRvICR7dG99IGNhbm5vdCBiZSBjYWxjdWxhdGVkIGFzICR7cmVhc29ufSBoYXMgYSBjb252ZXJzaW9uIGRpZmZlcmVuY2Ugd2hpY2ggY2Fubm90IGJlIGNvbnZlcnRlZCB3aXRoIGJpZ2ludHNgLFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcigpO1xuXHRcdH1cblxuXHRcdC8vIERpZmZlcmVuY2UgaXMgaW50ZW50aW9uYWxseSBleGNsdWRlZCBhcyB0aGVyZSBpcyBuZXZlciBhIGNhc2Ugd2hlcmUgeW91IGNvdWxkIGNvbnZlcnQgYSB0ZW1wZXJhdHVyZSB0byBhIGRpZmZlcmVudCB0ZW1wZXJhdHVyZSBhcyBpbnRlZ2Vyc1xuXHRcdHJldHVybiAodGhpcy5fcXVhbnRpdHkgKlxuXHRcdFx0Ly8gQ29udmVydGluZyBlYWNoIHJhdGlvIHRvIGJpZ2ludHMgd291bGQgbWFrZSB0aGUgbW9zdCBzZW5zZSBoZXJlIGJ1dCBpdCBlbmRzIHVwIHdpdGggdW5oZWxwZnVsIHJldHVybiB2YWx1ZXMgKGV4LiAxXzAwMF8wMDBuIEIgLT4gTUIgPT09IDBuIGluc3RlYWQgb2YgMW4pXG5cdFx0XHQvLyBJdCdzIG1vc3RseSBva2F5IHRvIGRvIHRoaXMgc2luY2UgcmF0aW9zIGFyZSBhbHJlYWR5IGBudW1iZXJgcyBzbyB3ZSBhcmVuJ3QgbG9zaW5nIGEgdG9uIG9mIHByZWNpc2lvbiwganVzdCBpZiB5b3UgaGF2ZSAyIHZlcnkgcHJlY2lzZSByYXRpb3MgdGhhdCBhcmUgbXVsdGlwbGllZCB0b2dldGhlciBhbmQgZXhjZWVkIHRoZSBwcmVjaXNpb24gb2YgYSBgbnVtYmVyYFxuXHRcdFx0QmlnSW50KHRoaXMuX2Zyb21Vbml0W0luZGV4ZXMuQ29udmVyc2lvbi5SYXRpb10gLyB0b1VuaXRbSW5kZXhlcy5Db252ZXJzaW9uLlJhdGlvXSkpIGFzIHVua25vd24gYXMgU2ltcGxpZnlRdWFudGl0eTxRPjtcblx0fVxuXG5cdGFzc2VydFR5cGU8bnVtYmVyPih0aGlzLl9xdWFudGl0eSk7XG5cblx0aWYgKHRoaXMuX2lzQ29udmVydGluZ1RlbXBlcmF0dXJlICYmIGlzVHlwZTxUZW1wZXJhdHVyZT4odGhpcy5fZnJvbSkgJiYgaXNUeXBlPFRlbXBlcmF0dXJlPih0bykpIHtcblx0XHRzd2l0Y2ggKHRvKSB7XG5cdFx0XHRjYXNlIEtlbHZpbk5hbWVzLks6XG5cdFx0XHRjYXNlIEtlbHZpbk5hbWVzLmtlbHZpbjpcblx0XHRcdGNhc2UgS2VsdmluTmFtZXMua2Vsdmluczoge1xuXHRcdFx0XHRpZiAodGhpcy5fZnJvbSBpbiB0ZW1wZXJhdHVyZURpZmZlcmVuY2VzICYmIGlzVHlwZTxUZW1wZXJhdHVyZVdpdGhEaWZmZXJlbmNlPih0aGlzLl9mcm9tKSkge1xuXHRcdFx0XHRcdHJldHVybiAoKHRoaXMuX3F1YW50aXR5ICsgdGVtcGVyYXR1cmVEaWZmZXJlbmNlc1t0aGlzLl9mcm9tXSkgKiB0aGlzLl9mcm9tVW5pdFtJbmRleGVzLkNvbnZlcnNpb24uUmF0aW9dKSBhcyB1bmtub3duIGFzIFNpbXBsaWZ5UXVhbnRpdHk8UT47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gKHRoaXMuX3F1YW50aXR5ICogdGhpcy5fZnJvbVVuaXRbSW5kZXhlcy5Db252ZXJzaW9uLlJhdGlvXSkgYXMgdW5rbm93biBhcyBTaW1wbGlmeVF1YW50aXR5PFE+O1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZhdWx0OiB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHN3aXRjaCAodGhpcy5fZnJvbSkge1xuXHRcdFx0Y2FzZSBLZWx2aW5OYW1lcy5LOlxuXHRcdFx0Y2FzZSBLZWx2aW5OYW1lcy5rZWx2aW46XG5cdFx0XHRjYXNlIEtlbHZpbk5hbWVzLmtlbHZpbnM6IHtcblx0XHRcdFx0aWYgKHRvIGluIHRlbXBlcmF0dXJlRGlmZmVyZW5jZXMgJiYgaXNUeXBlPFRlbXBlcmF0dXJlV2l0aERpZmZlcmVuY2U+KHRvKSkge1xuXHRcdFx0XHRcdHJldHVybiAodGhpcy5fcXVhbnRpdHkgLyB0b1VuaXRbSW5kZXhlcy5Db252ZXJzaW9uLlJhdGlvXSAtIHRlbXBlcmF0dXJlRGlmZmVyZW5jZXNbdG9dKSBhcyB1bmtub3duIGFzIFNpbXBsaWZ5UXVhbnRpdHk8UT47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gKHRoaXMuX3F1YW50aXR5IC8gdG9Vbml0W0luZGV4ZXMuQ29udmVyc2lvbi5SYXRpb10pIGFzIHVua25vd24gYXMgU2ltcGxpZnlRdWFudGl0eTxRPjtcblx0XHRcdH1cblxuXHRcdFx0ZGVmYXVsdDoge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY29udmVydChjb252ZXJ0KHRoaXMuX3F1YW50aXR5LCB0aGlzLl9mcm9tKS50bygnSycpLCAnSycpLnRvKHRvKSBhcyB1bmtub3duIGFzIFNpbXBsaWZ5UXVhbnRpdHk8UT47XG5cdH1cblxuXHRyZXR1cm4gKHRoaXMuX3F1YW50aXR5ICogKHRoaXMuX2Zyb21Vbml0W0luZGV4ZXMuQ29udmVyc2lvbi5SYXRpb10gLyB0b1VuaXRbSW5kZXhlcy5Db252ZXJzaW9uLlJhdGlvXSkpIGFzIHVua25vd24gYXMgU2ltcGxpZnlRdWFudGl0eTxRPjtcbn1cbiJdfQ==